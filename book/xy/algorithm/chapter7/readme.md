[source](https://juejin.cn/book/6844733800300150797/section/6844733800350498824)

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

1. 数组算法题一般会考什么呢？
    排序、二分和动态规划

- 一个“淳朴”的解法
    两层循环来遍历同一个数组；第一层循环遍历的值记为 a，第二层循环时遍历的值记为 b；若 a+b = 目标值，那么 a 和 b 对应的数组下标（i， j）就是我们想要的答案。
- 反思
    要有这样的一种本能 当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环
     O(n^2)  这个复杂度非常容易导致你的算法超时。

- 空间换时间，找谁帮忙？  {}或es6 Map
    如何设计这个对象呢？  值 和下表   
    大家记住一个结论：几乎所有的求和问题，都可以转化为求差问题
    我们可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的差值是否已经在前面的数字中出现过了。若出现过，那么答案已然显现，我们就不必再往下走了

合并两个有序数组
标准解法
这道题没有太多的弯弯绕绕，标准解法就是双指针法。首先我们定义两个指针，各指向两个数组生效部分的尾部：

为什么是从后往前填补？因为是要把所有的值合并到 nums1 里，所以说我们这里可以把 nums1 看做是一个“容器”。但是这个容器，它不是空的，而是前面几个坑有内容的。如果我们从前往后填补，就没法直接往对应的坑位赋值了（会产生值覆盖）。
从后往前填补，我们填的都是没有内容的坑，这样会省掉很多麻烦。

还要考虑什么问题？
由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个提前到头的这种情况：

如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。

如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是 nums1，所以此时不必做任何额外的操作。



作业， 请用Map 来写


