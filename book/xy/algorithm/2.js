// 增加元素 有几种方法？ 三种
// unshift 方法-添加元素到数组的头部
// const arr = [1,2];
// arr.unshift(0);
// push 方法-添加元素到数组的尾部
// arr.push(3) // [1,2,3]
// splice 方法-添加元素到数组的任何位置
// 传入两个以上参数这种用法，是用于在删除的同时完成数组元素的新增。而从第三个位置开始的入参，都代表着需要添加到数组里的元素的值：
// arr.splice(1,0,3);
// 相对熟悉的应该还是splice 用于删除的操作
// arr.splice(1,1)
// console.log(arr);

// 删除元素的三种做法
// shift 方法-删除数组头部的元素
// const arr = [1,2,3]
// arr.shift() // [2,3]
// console.log(arr);
// pop 方法-删除数组尾部的元素
// arr.pop()
// splice 方法-删除数组任意位置的元素

// - 何为栈？栈（Stack）——只用 pop 和 push 完成增删的“数组”
// 学校门口小卖部里  夏天会卖的什么特别像？ 
// 设计个 
// 冰柜的底部
// const stack = []  
// // 入栈过程
// stack.push('东北大板')
// stack.push('可爱多')
// stack.push('巧乐兹')
// stack.push('冰工厂')
// stack.push('光明奶砖')

// // 出栈过程，栈不为空时才执行
// while(stack.length) {
//     // 单纯访问栈顶元素（不出栈）
//     const top = stack[stack.length-1]
//     console.log('现在取出的冰淇淋是', top)  
//     // 将栈顶元素出栈
//     stack.pop()
// }

// // 栈空
// stack // []


// 队列（Queue）——只用 push 和 shift 完成增删的“数组”

// 它比较像咱们去肯德基排队点餐
// const queue = []  
// queue.push('小册一姐')
// queue.push('小册二姐')
// queue.push('小册三姐')  
  
// while(queue.length) {
//     // 单纯访问队头元素（不出队）
//     const top = queue[0]
//     console.log(top,'取餐')
//     // 将队头元素出队
//     queue.shift()
// }

// // 队空
// queue // []

// 链表 和数组类似的地方是？
// - 它们都是有序的列表、都是线性结构
// - 有且仅有一个前驱、有且仅有一个后继  区别于树
// 不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。
// 正是由于数组中的元素是连续的，每个元素的内存地址可以根据其索引距离数组头部的距离来计算出来。因此对数组来说，每一个元素都可以通过数组的索引下标直接定位。
// 但是对链表来说，元素和元素之间似乎毫无内存上的瓜葛可言。就比如说咱们图上这种情况，1、2、3、4、5各据山头，站在元素1的坑位里，我们对元素2、3、4、5的内存地址一无所知，连遍历都没法遍历，这可咋整？

// 没有关联，就创造关联！

// 数据域和指针域  JS 中的链表，是以嵌套的对象的形式来实现的：
// ```js
// {
//     // 数据域
//     val: 1,
//     // 指针域，指向下一个结点
//     next: {
//         val:2,
//         next: ...
//     }
// }  
// ```

function ListNode(val) {
    this.val = val;
    this.next = null;
}

const node = new ListNode(1)  
node.next = new ListNode(2)

// 先来说说添加  
// 直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。这里记值为2的 node 结点为 node2（假设 node2 是现在的尾部结点），值为3的 node 结点为 node3。假如我要把 node3 添加到 node2 所在链表的尾部，直接把 node2 的 next 指针指向 node3 即可：

// 如何在两个结点间插入一个结点？注意，
// 由于链表有时会有头结点，这时即便你是往链表头部增加结点，
// 其本质也是“在头结点和第一个结点之间插入一个新结点”。
// 所以说，任意两结点间插入一个新结点这种类型的增加操作，
// 将会是链表基础中的一个关键考点。
// 前驱结点和目标结点的 next 指针指向
// const node3 = new ListNode(3)     
// // 把node3的 next 指针指向 node2（即 node1.next）
// node3.next = node1.next
// // 把node1的 next 指针指向 node3
// node1.next = node3

// 链表元素的删除
// 链表元素的删除也是非常高频的操作。
// 延续我们前面的思路，仍然把重心放在对 next 指针的调整上。
// 删除的标准是：在链表的遍历过程中，无法再遍历到某个结点的存在。
// 按照这个标准，要想遍历不到
//  node3，我们直接让它的前驱结点 node1 的 next 指针跳过它、
//  指向 node3 的后继即可：

// 这里给大家提个醒：在涉及链表删除操作的题目中，
// 重点不是定位目标结点，而是定位目标结点的前驱结点。

// const target = node1.next  
// node1.next = target.next
// 链表和数组的辨析
// 数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，
// 如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。
// 我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，
// 呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。
// 但 JS 中不一定是。
// const arr = [1,2,3,4] //它是一个纯数字数组，那么对应的确实是连续内存。

const arr = ['haha', 1, {a:1}]// 它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。
// JS 数组未必是真正的数组
// 相对于数组来说，链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。
// 高效的增删操作
// 不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。
// 麻烦的访问操作
// 当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，
// const index = 10  
// // 设一个游标指向链表第一个结点，从第一个结点开始遍历
// let node = head  
// // 反复遍历到第10个结点为止
// for(let i=0;i<index&&node;i++) {
//     node = node.next
// }
// 随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

// 但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：