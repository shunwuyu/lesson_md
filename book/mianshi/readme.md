[source](https://juejin.cn/book/6844733763675488269/section/6844733763759374349)

2.js 先来问

- 原始类型  相对于 对象数据类型 区别是？
    原始类型存储的都是值
    1.js
    '1'.toString()
    对象类型存储的是地址
    const a = []   发生了什么?
    常量 a  假设内存地址（指针）为 #001  
    在地址 #001 的位置存放了值 []
    常量 a 存放了地址（指针） #001

    ```
    const a = []
    const b = a
    b.push(1)
    ```
    当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。

- 2.js

- 3.js
    typeof 是否能正确判断类型
    对于原始类型来说，除了 null 都可以显示正确的类型
    typeof 1 // 'number'
    typeof '1' // 'string'
    typeof undefined // 'undefined'
    typeof true // 'boolean'
    typeof Symbol()

    typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型

    如果我们想判断一个对象的正确类型? 
    这时候可以考虑使用 instanceof  4.js

- 在 JS 中类型转换的情况 只有三种, 猜一猜是哪三种? 
    - 转换为布尔值
        除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象
        5.js
    - 转换为数字

    - 转换为字符串

    加法运算符   6.js
    - 运算中其中一方为字符串，那么就会把另一方也转换为字符串
    - 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

    对象转变为原始数据类型
     JavaScript中有没有可能让(a== 1 && a ==2 && a==3)返回true?
     JS中使用==对两个值进行比较时，会进行如下操作：
     1. 将两个被比较的值转换为相同的类型。
     2. 转换后（等式的一边或两边都可能被转换）再进行值的比较。

     a == 1  有以下几种
    1. a类型为String，并且可转换为数字1（'1' == 1 => true）
    2. a类型为Boolean，并且可转换为数字1 (true == 1 => true)
    3. a类型为Object，通过转换机制后，可转换为数字1 。

    对象转原始类型的"转换机制"
    对象转原始类型，会调用内置的[ToPrimitive]函数，逻辑大致如下
    2. 调用valueOf，如果可以转换为原始类型，则返回，否则进行3。
    3. 调用toString，如果可以转换为原始类型，则返回，否则进行4。

    7.js
