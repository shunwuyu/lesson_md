## LHS和RHS查询：作用域链的两大利器
[](https://juejin.im/post/5c8efeb1e51d45614372addd)

- JavaScript 是如何编译执行的？
  分词 token
  ```js
    var sum = 30;
// 词法分析后的结果
  [
    "var" : "keyword",
    "sum" : "identifier",
    "="   : "assignment",
    "30"  : "integer",
    ";"   : "eos" (end of statement)
  ]

  ```
  语法分析
  把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” AST
  代码生成
  将抽象语法树（AST）转换为一组机器指令，也就是可执行代码，简单说，就是用来创建一个变量a，并将3这个值储存在a中。

  1.4 JavaScript 编译过程的不同处
  JavaScript 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内
  JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳

  核心重点：变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。
  函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。

- 查找作用域时是如何一层层往上查询的？
- JavaScript作用域链的本质是？

demo 3.js
### 例子一
  分析阶段
  函数运行的瞬间， 创建一个AO(Active Object 活动对象), 相当于载体
  AO = { }
  - 分析函数参数
    形式参数 AO.age = undefined 
    实参 AO.age = 18
  - 分析变量声明
    有同名属性， 不做任何事。 AO.age = 18
  - 分析函数声明
    AO.age = function age() {}
    AO上如果有与函数名同名的属性,则会被此函数覆盖。
    因为函数在JS领域,也是变量的一种类型

    变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。
    函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。

demo 4.js
### 例子二
  * 第一步，分析函数参数 *
  形式参数：AO.age = undefined
  实参：AO.age = 18
  * 第二步，分析变量声明 *
  * 第三步，分析函数声明（无） *
    AO.age = 18

### 例子三
  第一步，分析函数参数：AO.age = 18
  第二步，分析变量声明：有同名属性,不做任何事 AO.age = 18
  第三步，分析函数声明（无）

## 执行总结：何为作用域链
  JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到大boss:window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。

## LHS和RHS查询：作用域链的两大利器
  引擎对变量进行查询的时候

  LHS = 变量赋值或写入内存。想象为将文本文件保存到硬盘中
  RHS = 变量查找或从内存中读取。想象为从硬盘打开文本文件

  3.1 两者的特性
  - 都会在所有作用域中查询
  - 严格模式下，找不到所需的变量时，引擎都会抛出ReferenceError异常。
  - 非严格模式下，LHR稍微比较特殊: 会自动创建一个全局变量
  - 查询成功时，如果对变量的值进行不合理的操作，比如：对一个非函数类型的值进行函数调用，引擎会抛出TypeError异常

  我也总结了一个作用域链口诀，教你快速找到输出：
  - 分析阶段创AO，参数看完找变量，变量不顶函数顶，顶完之后定乾坤。
  - 执行阶段看LR，内层不行找外层，翻遍楼层找不到，抛个异常连连看。

