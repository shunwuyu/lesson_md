// - 闭包 = ？
//     外部变量 + 函数
//     ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5265f8d31eca43429d7df1b3e533adeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
// - 闭包带来了什么能力？
//     闭包给了函数访问外部变量的能力，
// - (function (){})() 是闭包吗？
//     不是闭包，这是个自执行函数
// - 什么是作用域
//     就是一个东西（变量、函数、其他）起作用的范围
// function fn1() {
//     //1-定义一个变量
//     let str = 'Blue真帅';
// }
  
// function fn2() {
// //2-试图使用这个变量
//     console.log(str); //报错：str is not defined
// }
  
// fn1();
// fn2();
// 局部变量，就像函数的私有财产，
// 局部变量只能在定义它的函数内使用
// 有例外吗？ 可以举个例子吗？
// function fn1() {
//     let str = 'Blue真帅';
  
//     function fn2() {
//       console.log(str); //正常弹出
//     }
  
//     fn2();
//   }
  
//   fn1();

// 闭包含义一   在JS中，子函数可以直接使用父函数的局部变量

// 计算机的资源是有限的，所以用完的东西就要尽快释放掉，
// 而垃圾回收粗略的可以分两个阶段：
// 手动回收  delete  
// 自动回收 Garbage Collection
// GC（自动垃圾收集机制）是非常方便的，
// 但垃圾回收需要一定的标准，不能把别人还在用的东西回收了
// 哪些变量是垃圾，可以被回收

function show() {
    //我们有一个局部变量a
    let a = '欢迎大家阅读blue的教程，如果喜欢，请点赞，谢谢';
}

//粗略的分为?个三个阶段：
//1.show执行前：a是不存在的，不占空间
// show(); //2.show执行时：a被分配空间
//3.show结束后：a的生存周期结束，可以被回收

// 所以，局部变量（通常）在函数执行后，
// 就会被回收（当然，变量其实并没有被立即回收，
// 而是被标记为“可回收”，在下一次GC工作时被带走）

// 作用域决定了
// 局部变量（通常）在函数执行后，就会被回收

// 那……跟闭包有啥关系

function show() {
    let str = '欢迎观看blue的教程';
  
    document.onclick = function() {
      alert(str);
    };
  }
  
  //执行前，str不存在
  show(); //执行时，str被创建
  //执行后，str“本应”被回收
  
//   函数的存在，延长了外层局部变量的生存周期，只要这个onclick函数还在，
//   那么它（onclick函数）外面的局部变量就不会回收

// 闭包的含义2
// 函数的存在， 延长了外层局部变量的生命周期

// - js怎么知道你用了哪些局部变量的？
// 要保留哪些局部变量不回收？
// - js如何确定onclick消失后要回收哪些变量？
// - 父级的变量不回收，那父级的父级呢？

// 延伸问题1-js如何确定哪些父级变量要保留？
// js不需要确定，它直接保留全部父级变量，
// 用没用到都保留

function show() {
    let a = 12;
    let b = 5;
  
    document.onclick = function() {
      console.log(eval(prompt('请随便输入一个表达式')));
    };
  }
  
  show();

//   我们并没有显式的引用任何一个父级变量
// 用不用到都保留，那这多浪费资源啊
// 健壮性：代码是一个极其复杂的东西，理论上官方不可能100%不出错的确定哪些用了哪些没用，而如果误回收了变量，会导致程序崩溃，所以全都保留是出于程序健壮性的考虑
// 性能考虑：就算假设有办法判定一段代码里到底用了什么，也会是非常复杂的，会造成大量的运行时开销，反而造成程序性能降低，得不偿失
// 闭包会保留全部父级变量，不论用没用
// 延伸问题2-引用计数机制
// js（包括java等依赖gc的语言都是）依靠引用计数机制，确定一个东西是否能回收
// 闭包的存在，不仅延长父级的局部变量有效期，父级的父级、父级的父级的父级...一直到全局的，其实都会延长
