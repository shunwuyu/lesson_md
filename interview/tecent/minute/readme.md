[非科班二本前端大厂面试的心路历程和总结（腾讯、头条、阿里、京东） | 掘金技术征文](https://juejin.cn/post/6844904111150727181#heading-16)

- 双向绑定
    v-model
- 手写bind  es6 写法
    function myBind(fn, context) {
        return function(...args) {
            fn.apply(context, args);
        }
    }
- 手写new
    - 创建一个新的对象。
    - 将该对象的原型指向构造函数的 prototype 属性。
    - 执行构造函数，并将 this 指向新创建的对象
    - 如果构造函数返回的值为对象，则返回该对象；否则返回新创建的对象

    function myNew(Constructor, ...args) {
        const obj = Object.create(Constructor.prototype);
        const result = Constructor.apply(obj, args);
        return (typeof result === 'object' && result !== null) ? result : obj;
    }

- 二分查找
    bs

- JSON.stringify(JSON.stringify(arr)) 缺点
    - 该方法不能序列化函数和循环引用对象
        抛出错误 或 忽略函数
    - 将一个数组转换为 JSON 字符串可以理解为将其序列化，再次调用 JSON.stringify() 将其序列化的结果再次转换为字符串，这就增加了处理数据的时间和空间成本
    
2. 如何从生命周期角度解释多层组件传值
    - 父组件将数据传递给子组件
        ，父组件通过 props 将数据传递给子组件。这个过程通常发生在父组件的 created 和 mounted 钩子函数中。当父组件传递数据给子组件时，Vue 会在子组件的 props 中设置这些数据。在子组件的 created 和 mounted 钩子函数中，我们可以访问这些 props。
    - 子组件接收到数据
        一旦父组件将数据传递给子组件，子组件就可以访问这些数据了。在子组件的 created 和 mounted 钩子函数中，我们可以使用 this.$props 访问这些数据。此外，在子组件的 updated 钩子函数中，也会更新这些数据。
    - 子组件修改数据并将其传递回父组件
        在某些情况下，子组件需要修改由父组件传递的数据。这时，子组件可以通过 $emit 方法触发一个事件，并将修改后的数据作为参数传递给父组件。在父组件中，我们可以在监听子组件的事件时访问这些参数，并将它们保存在父组件的数据中。
    - 父组件重新渲染
        一旦父组件的数据发生变化，父组件就会重新渲染。在父组件的 updated 钩子函数中，我们可以访问更新后的数据，并将其传递给子组件。

- 实现正则获取url params  
    https://www.example.com/?name=John&age=30&location=New+York

    paras.js

- 简述cdn原理
    Content Delivery Network），即内容分发网络，是一种通过将内容分发到离用户更近的服务器上来提高网络访问速度和用户访问体验的技术。
    - 首先，CDN 会将源站的内容缓存到分布在全球各地的边缘节点服务器中。这些服务器通常由 CDN 服务供应商管理和维护。
    - 当用户请求访问某个网站时，CDN 会根据用户的物理位置和网络状况选择最近的边缘节点服务器，并从该服务器获取所需的内容。
    - 如果该边缘节点服务器没有缓存所需的内容，则它会向其它边缘节点服务器或源站请求内容，并将获取到的内容保存到本地缓存中。
    - 之后，该边缘节点服务器将所需的内容返回给用户，同时还会将该内容缓存到本地，以备下次使用

    使用 CDN 技术，用户可以更快地访问网站内容，而网站也能够减轻服务器负载压力，提高访问效率和稳定性。

- 描述https 原理
    - 客户端向服务端发送一个HTTPS请求，并在请求头中声明自己支持HTTPS
        Upgrade-Insecure-Requests  1   juejin有
        Strict-Transport-Security
        Content-Security-Policy
    - 服务端向客户端发送数字证书，其中包含了服务端的公钥、证书颁发机构(CA)的签名等信息
    - 客户端收到数字证书后，首先要验证数字证书的合法性，这一过程被称为证书验证。证书验证主要包括以下几个步骤
        - 验证数字证书中包含的CA根证书是否在本地受信任CA列表中。如果是，则表示数字证书是可信的；否则需要从数字证书中找到其上级CA的证书，递归验证直到找到根证书。 浏览器自带
        - 验证数字证书中的所有字段是否符合规范，例如证书有效期、签名算法等
        - 验证数字证书中的公钥是否可以正确解密数字签名
    - 客户端生成一个随机数，称为pre-master secret，并用服务端的公钥对其进行加密，然后将加密后的pre-master secret发送给服务端。
        非对称加密
    - 服务端使用自己的私钥对pre-master secret进行解密，得到客户端生成的pre-master secret
        非对称加密
    - 客户端和服务端使用pre-master secret共同生成一个称为master secret的密钥，该密钥用于加密数据传输
    - 客户端和服务端各自使用master secret生成对称密钥，用于对数据进行加密和解密。
- 操作系统
    - 进程是操作系统分配资源的基本单位，具有独立的内存空间；线程是进程的执行单元，多个线程可以共享进程的资源和上下文。
    - chrome 里  js  和  css 是如何在各自线程里 工作的
        1. UI 线程：负责渲染页面、响应用户输入事件等  chrome 面板
        2. JavaScript 引擎线程：负责解析和执行 JavaScript 代码，与 DOM 操作有关的也会在这个线程上执行
        3. 样式计算线程：负责计算 CSS 样式规则，并将计算结果存储在内存中，以供后续使用。
        4. 布局线程：负责计算元素的位置和大小，并决定它们在页面中的布局。
        5. 绘制线程：负责将元素渲染到屏幕上。

        当节点对象需要渲染到页面时，首先会进行样式计算，然后进行布局计算，再进行绘制操作。  所以减少重绘重排'
    - 进程间通信
        进程间通信是指不同进程之间进行数据交换和共享的过程。在操作系统中，进程间通信常用的方法有以下几种：

        管道（Pipe）：管道是一种半双工的通信方式，在 Unix/Linux 系统中，可以通过 fork() 函数创建一个子进程，并使用管道来实现父子进程之间的通信。

        共享内存（Shared Memory）：共享内存是一种高效的通信方式，多个进程可以共享同一块内存区域，从而避免了数据复制的开销。
            兄弟之间

        信号量（Semaphore）：信号量是一种进程间同步和互斥的机制，可以用来控制对共享资源的访问。

        消息队列（Message Queue）：消息队列是一种异步的通信方式，进程可以向队列中发送消息，而不需要知道消息接收者的身份。
            订阅发布者

        套接字（Socket）：套接字是一种基于网络协议的通信方式，可以在本地或远程主机之间传输数据，是分布式系统中常用的通信方式之一。

        以上是常用的几种进程间通信方式，不同的通信方式适用于不同的场景和问题。在实际开发中，需要根据具体的需求选择合适的通信方式来实现进程间的数据交换和共享。

- 内存泄漏是什么？如何避免和解决内存泄漏问题？
    - 内存泄漏是指在程序中分配的内存空间没有被正确释放，导致这些内存空间无法再次使用，最终导致系统可用内存变少，甚至引起系统崩溃。内存泄漏问题常见于长时间运行的程序或者需要频繁动态分配内存空间的场景。

    为了避免和解决内存泄漏问题，可以采取以下措施：
        - 及时释放不再使用的内存空间：对于已经分配的内存空间，及时进行释放操作，避免出现不必要的内存占用。
            weakmap
            变量的内存空间通常是由垃圾回收机制自动管理的，即当一个变量不再被引用时，垃圾回收机制会自动将其占用的内存空间释放。因此，在大多数情况下，我们无需手动释放变量。
            但有时候，我们可能需要手动释放一些特定的资源，如清除定时器、断开网络连接等。针对这种情况，我们可以手动将变量赋值为 null，这样就可以解除该变量对应内存空间的引用，从而让垃圾回收机制能够及时回收这部分内存空间
            var timer = setTimeout(function() {
            console.log("Hello world!");
            }, 1000);

            // 取消定时器
            clearTimeout(timer);

            // 手动释放变量
            timer = null;
        - 避免循环引用：如果对象之间存在相互引用的情况，需要注意避免形成循环引用，否则就会导致内存泄漏。
            
        - 合理使用闭包：在使用闭包的过程中，需要注意内存管理，避免形成不必要的闭包引用，从而导致内存泄漏问题。
            function outer() {
            var x = "Hello";
                return function inner() {
                    console.log(x);
                }
            }

            var closureFn = outer();
            closureFn = null; // 解除外部对闭包函数的引用
            outer 函数返回了一个内部函数 inner，由于 inner 函数形成了闭包引用，使得 x 变量无法被垃圾回收机制回收，即使外部通过将 closureFn 指向 null 解除了对闭包函数的引用，但 x 变量仍然占用着内存空间，导致内存泄漏。

            可以使用一个自执行的匿名函数来保存 x 变量的值，从而避免了闭包引用，代码如下：

            var closureFn = (function(){
                var x = "Hello";
                return function inner() {
                    console.log(x);
                }
            })();

            closureFn = null;

- 垃圾回收
    https://juejin.cn/post/6844903646623186958



- 如何减少重绘重排
    - 使用 CSS3 动画代替 JavaScript 动画：CSS3 动画使用 GPU 加速，比 JavaScript 动画更加高效。
    - 避免频繁地操作 DOM：DOM 操作是非常昂贵的，过度的 DOM 操作会导致浏览器不断地进行重排和重绘，因此应该尽量减少 DOM 操作次数。
        - 如何从线程的角度理解DOM 操作是非常昂贵的
            DOM 操作是非常昂贵的，因为它们会触发浏览器的渲染引擎重新计算页面布局，并对整个文档进行重绘或重排。

            从线程的角度来看，当我们进行 DOM 操作时，浏览器主线程会被阻塞，直到操作完成。这也就意味着，在进行 DOM 操作期间，浏览器无法处理其他任务，例如响应用户输入或处理 JavaScript 代码等。

            此外，由于浏览器的主线程同时还要处理网络请求、JavaScript 等任务，如果我们频繁地进行 DOM 操作，那么它们可能会导致主线程长时间被占用，从而影响页面的性能和流畅度。

            因此，尽量避免频繁的 DOM 操作，可以让页面更加快速和流畅。如果需要对 DOM 进行多次操作，可以将这些操作合并成一次操作，或者使用文档片段等技术批量修改 DOM 节点。
    - 对于复杂的布局，使用 flexbox 和 grid 布局代替传统的布局方式：flexbox 和 grid 布局可以更好地优化渲染性能
        为什么？
        - 灵活的盒子大小和位置控制，可以避免在页面中使用绝对定位或浮动定位引起的性能问题。
        - 不会影响其他元素：当使用 Flexbox 布局时，一个元素的大小和位置变化不会影响其他元素的大小和位置，因此避免了重排过程中对其他元素进行重新计算的情况。
    - 最小化页面中的样式变化：样式的改变可能导致重排和重绘。最小化样式变化可以减少这种情况的发生。
        用css类名切换
    - 将页面上的元素分成图层：将需要频繁更新的元素放在单独的层中，可以减少整个页面的重排和重绘。 
        z-index
    - 避免使用 table 布局：table 布局对于渲染性能有很大的影响，应该避免使用。
    - 使用缓存机制：缓存可以避免页面重复请求相同的资源，从而减少网络请求的次数和页面渲染的时间

- xss是什么？如何防范？具体例子，jsonp如何防止xss？
    XSS（Cross-Site Scripting）是一种常见的网络安全漏洞，攻击者通过注入恶意脚本来在受害者的浏览器中执行非法操作。
    ![](https://img0.baidu.com/it/u=4063457274,3011692899&fm=253&fmt=auto&app=138&f=JPG?w=763&h=500)
    怎么防范
    为了防范 XSS 攻击，可以采取以下几个措施：

    输入验证：在前端和后端都对用户输入的内容进行验证和过滤，去除或转义一些危险字符，例如 <, >, & 等。

    输出转义：在输出用户提交的数据时，对数据中包含的特殊字符进行转义，例如将 < 转义成 &lt;、> 转义成 &gt; 等。这可以通过编码函数如 encodeURIComponent() 或者使用库如 DOMPurify 达到。

    CSP（Content Security Policy）: CSP 是一种安全策略，用于定义可信任的资源来源，限制非法脚本的注入。开启 CSP 可以有效地防止 XSS 攻击。
        是一种安全策略，用于限制外部资源的加载和执行

    HttpOnly 标记：在设置 Cookie 时添加 HttpOnly 属性可以防止恶意脚本读取和修改浏览器中的 Cookie。

    防止跨站点请求伪造（CSRF）：CSRF 是一种利用用户的登录态发起非法操作的攻击方式，合理使用 Token 和验证码等技术可以有效地防御 CSRF 攻击。

    - csrf 
        CSRF（Cross-Site Request Forgery）是一种利用用户登录态发起非法操作的攻击方式。下面是一个 CSRF 的例子：
        钓鱼
        <form action="https://example.com/transfer" method="post">
            <input type="hidden" name="to" value="attacker">
            <input type="hidden" name="amount" value="1000">
            <button type="submit">Transfer $1000 to Attacker</button>
        </form>
        攻击者可以通过将上述代码嵌入到自己的网站中，并在用户浏览器中展示出来，诱使用户点击 "Transfer $1000 to Attacker" 按钮。当用户点击按钮时，网站会向 https://example.com/transfer 发送请求，将 $1000 转到攻击者的账户。

        这种攻击方式可以通过添加 CSRF token 等技术手段进行防范。通常情况下，服务器会生成一个随机的 token 并将其与用户的会话关联起来，在提交表单时要求同时提交此 token，从而验证请求是否合法。

        CSRF Token 是一种用于防范 CSRF 攻击的技术手段。在应用程序中使用 CSRF Token 可以在一定程度上保护用户会话安全。

        CSRF Token 的实现方式通常是将一个随机生成的 token 值添加到表单中，并在后台对此值进行验证。具体而言，应用程序会在用户登录时为其生成一个 CSRF Token，并将该 Token 存储在服务端 Session 中。当用户提交表单时，应用程序会将 CSRF Token 作为隐藏字段加入表单中一并提交，然后在后台对比表单提交的 CSRF Token 和存储在 Session 中的 Token 是否一致。如果不一致，则拒绝此次请求。

        使用 CSRF Token 可以有效地防止 CSRF 攻击，因为攻击者无法获取到存储在用户浏览器中的 CSRF Token，从而无法伪造符合要求的表单数据提交到服务器。