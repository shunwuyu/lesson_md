[编译器和解释器：V8是如何执行一段JavaScript代码的？](https://time.geekbang.org/column/article/131887)
[HTTP/1：HTTP性能优化](https://time.geekbang.org/column/article/147501)
[30｜HTTP/2：如何提升网络速度？](https://time.geekbang.org/column/article/148546)


- Babel 的工作原理是
    Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

- Javascript 代码是如何被执行的
    - 站在 JavaScript 引擎 V8 的视角

- 了解抽象语法树， 有利于解决哪些问题？
    JavaScript运行
    语言转换器 Babel
    语法检查工具 ESLint
        eslint-demo
    前端框架 Vue 和 React 的一些底层实现机制

- V8 的工作原理
    编译器（Compiler）
    解释器（Interpreter）
    抽象语法树（AST）
    字节码（Bytecode）
    即时编译器（JIT）

- 为什么需要编译器和解释器？
    机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言
- 编译器和解释器 为什么需要两个？
    - 按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
    - 型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言
    - 由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。

    图里的区别
    ![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png?wh=1142*510)
    ![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png?wh=1142*510)

- 词法分析， 语法分析有什么区别
    任务不一样 词法分析的主要任务是将源代码中的字符序列转换为标记（token）序列
    语法分析的任务是检查标记序列是否遵循语言的语法规则，并构建一个语法树（parse tree）来表示程序的结构

- 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。
    
- 为什么需要字节码
    通过字节码编译，V8还可以使用一些优化技术来提高代码的执行效率，例如：垃圾回收、内联缓存、静态类型优化等，这些技术可以使代码在执行过程中更快地执行，从而提高应用程序的整体性能。

    因此，将AST转换为字节码是V8引擎优化性能的重要步骤之一。

- V8是如何执行一段 JavaScript 代码的
    ![](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png?wh=1142*522)

- 为什么需要AST
    AST 是非常重要的一种数据结构
    对于编译器或者解释器来说，它们可以理解的就是 AST
    编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。
- 源代码转换为抽象语法树，并生成执行上下文
    主要是代码在执行过程中的环境信息

- 用一段代码感受AST?
    var myName = "极客时间"function foo(){ return 23;}myName = "geektime"foo()
    在线试下
    https://www.jointjs.com/demos/abstract-syntax-tree

- 生成AST 需要两个阶段
    - 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串
    ![分解 token 示意图](https://static001.geekbang.org/resource/image/83/f5/838028071f63a132cc8b27b23960e5f5.png?wh=1142*505)
    - 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。
        但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

- 有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

- 为什么需要字节码
    其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

- 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

![字节码和机器码占用空间对比](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png?wh=1142*314)

- 什么是 DOM
    从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构, 这个结构就是 DOM
    DOM 提供了对 HTML 文档结构化的表述

DOM 树是怎么生成的？


# JavaScript是如何影响DOM树构建的？


- KMP 算法
    - 字符串匹配算法
    - Knuth-Morris-Pratt
    - 求解一个字符串的最长回文子串
        - 回文
            正反两个方向读取都相同
        - 最值
            动态规划算法来解决
        1. 定义状态：使用一个二维布尔数组dp[i][j]表示从i到j的子串是否为回文串
        2. 初始化状态：对角线上的元素都为true，因为单个字符也是回文串
        3. 状态转移：如果s[i]等于s[j]并且dp[i+1][j-1]为true（即s[i+1]到s[j-1]也是回文串），则dp[i][j]为true；否则为false
        4. 更新答案：记录所有为true的dp[i][j]对应的子串，找到其中长度最长的子串即为所求的最长回文子串

        longestPalindrome
- HTTP是什么？
    HTTP 是浏览器和服务器之间的通信语言
    超文本传输

- HTTP性能优化
    - 如何看待http的各个版本
        - 即将完成使命的 HTTP/1
        - 正在向我们走来的 HTTP/2
        - 以及未来的 HTTP/3
    - 在进化过程中所遇到的各种瓶颈，以及对应的解决方法
    - 超文本传输协议 HTTP/0.9
        - 用来在网络之间传递 HTML 超文本的内容
        - 采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。简单
        - 为什么需要IP地址？  还需要什么？
            因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程
        - 建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html。
        - 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。
        - HTML 文档传输完成后，断开连接。
            ![](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png?wh=1142*309)
        - 优点
            - 第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
            - 第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
            - 第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。
    - 被浏览器推动的 HTTP/1.0
        1994 年底出现了拨号上网服务，同年网景又推出一款浏览器
        - 新兴网络带来哪些需求
            1. 浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件
        - 如何实现多种类型文件的下载呢
            HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的 ,为了让客户端和服务器能更深入地交流
        ![1.0](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png?wh=1142*309)

    - HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？
        返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码
        accept: text/htmlaccept-encoding: gzip, deflate, braccept-Charset: ISO-8859-1,utf-8accept-language: zh-CN,zh

    http 1.0 请求头， 响应头
        压缩， 编码 语言 格式 状态码
        Cache（服务器压力）用户代理（统计）

    - http 1.0 遇到哪些问题？
        1. 改进持久连接
        但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。
        HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。
        目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接

- 各个版本的不足
    1. HTTP 0.9的主要不足是缺乏请求头和版本控制，只能发送纯文本内容，并且无法支持多种HTTP方法
    2. HTTP 1.0的主要不足是缺乏持久连接、请求头和响应头字段较少、无法处理多个并发请求和响应、未支持虚拟主机等功能
    3. HTTP 1.1的主要不足包括头部信息过长、队头阻塞（Head-of-Line Blocking）问题、不能有效处理高带宽和高延迟网络、安全性较弱（明文传输）、无法支持服务器推送等

- HTTPS 是在哪个版本提供的
    HTTPS是在HTTP 1.0之后的HTTP 1.1版本中首次提出，并得到了广泛采用。HTTPS通过使用SSL/TLS协议，为HTTP连接提供了加密和认证机制，以保证网络通信的安全性。

- hooks-demo
    表单hooks

- 排序算法
    sort 
    - 快排的两种解法
        - 递归
            递归快排需要使用系统栈，每次递归调用都会将一些数据压入栈中。
            当需要处理的数据量很大时，递归的深度就会变得非常深，导致系统栈空间不足而发生栈溢出
        - 非稳定性：由于递归快排是通过分治思想实现的，因此在交换元素的过程中可能会改变相同元素的相对顺序
    
    

