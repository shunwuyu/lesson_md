[source](https://juejin.cn/post/6844904100945985543)
[demo](https://blog.csdn.net/frontend_frank/article/details/107054146)

- 信息安全最基本的概念是？
    CIA 三元组， 不是美国中央情报局
    - 机密性 Confidentiality   
        防止未授权的用户访问数据， 不能看
        通常会在数据的处理、传输、储存过程中进行一些诸如加密或者权限类的保护措施来进行安全控制
        举个例子？  password  ***  肩窥 
    - 完整性 Integrity
        防止未授权的修改数据，也就是：“不能改”
        针对完整性的破坏主要有病毒、应用程序错误、逻辑炸弹，以及被授权用户的非授权操作。
        完整性依赖于机密性，如果没有机密性，也就无法维护完整性。
    - 可用性 Availability
        可用性是保证经过授权的客户能及时准确的不间断的访问数据，也就是“一直用”
        可用性依赖于完整性和机密性

    不同机构对CIA三元组的需求重点是不同的, 如军队和政府更倾向于更高的机密性，而私人企业更倾向较高的可用性。

- XSS是什么？
    Cross-Site Scripting 跨站脚本攻击
    黑客在你的浏览器中插入一段恶意 JavaScript 脚本，窃取你的隐私信息、冒充你的身份进行操作

    因为浏览器无法区分脚本是被恶意注入的还是正常的内容，它都会执行，况且 HTML 非常灵活，可以在任何时候对它进行修改

    ```
    在接口参数中加入跨站脚本>\"'><script>alert('xss')</script>
    ```

    - 有哪几种类型？

        1. 反射型 XSS (也叫非持久型)
            恶意 JavaScript 脚本属于用户发送给网站请求中的一部分
            随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。
            传统前后端, 要经过服务器
            demo1
            可以窃取 cookie信息。恶意 JavaScript可以通过 ”doccument.cookie“获取cookie信息，然后通过 XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器；恶意服务器拿到用户的cookie信息之后，就可以在其他电脑上模拟用户的登陆，然后进行转账操作。

            可以监听用户行为。恶意JavaScript可以使用 "addEventListener"接口来监听键盘事件，比如可以获取用户输入的银行卡等信息，又可以做很多违法的事情。

            可以修改DOM 伪造假的登陆窗口，用来欺骗用户输入用户名和密码等信息。

            还可以在页面内生成浮窗广告，这些广告会严重影响用户体验。
            运行商干过 
        2. 基于 DOM 的 XSS
            目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。
            demo3
            通过恶意脚本修改页面的DOM节点，是发生在前端的攻击
            1. 攻击者构造出特殊的URL，其中包含恶意代码
            2. 用户打开带有恶意代码的URL
            3. 用户浏览器接受到响应后执行解析，前端JavaScript取出URL中的恶意代码并执行
            4. 恶意代码窃取用户数据并发送到攻击者的网站，冒充用户行为，调用目标网站接口执行攻击者指定的操作。
        3. 存储型 XSS (也叫持久型 XSS)
            又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。
            比较常见的一个场景就是，攻击者在社区或论坛写下一篇包含恶意 JavaScript代码的博客文章或评论，文章或评论发表后，所有访问该博客文章或评论的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。
            步骤
                1. 首先攻击者利用站点漏洞将一段恶意JavaScript代码提交到网站数据库中
                2. 然后用户向网站请求包含了恶意 JavaScript脚本的页面
                3. 当用户浏览该页面的时候，恶意脚本就会将用户的cookie信息等数据上传到服务器
            demo2
                <script>alert('存储型 XSS 攻击')</script>

- 区别
    反射型的 XSS 的恶意脚本存在 URL 里，存储型 XSS 的恶意代码存在数据库里。
    而基于DOM型的XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，其他两种 XSS 都属于服务端的安全漏洞。

![反射型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/23/171080fa3388d36e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
![基于DOM型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/23/171080fbbac923a7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
![存储型](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/23/171080fd60f96569~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

- 黑客可以通过XSS攻击做哪些事儿
    1. 盗取用户 Cookie
    2. 未授权操作
    3. 修改 DOM
    4. 刷浮窗广告
    5. 发动 XSS 蠕虫攻击
    6. 劫持用户行为，进一步渗透内网
- XSS攻击如何进行防护
    1. 一切用户输入皆不可信，在输出时进行验证
    2. 将 HTML 元素内容、属性以及 URL 请求参数、CSS 值进行编码
    3. 当编码影响业务时，使用白名单规则进行检测和过滤
    4. 使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单
    5. 设置 Cookie 的 HttpOnly 属性
        避免js脚本操作cookie，即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志

- CSRF
    Cross-site request forgery 跨站请求伪造
    CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求

    攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。 利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证， 达到冒充用户对被攻击的网站执行某项操作的目的。

    - 最容易实现的是 Get 请求，一般进入黑客网站后，可以通过设置 img的 src 属性来自动发起请求
    - 在黑客的网站中，构造隐藏表单来自动发起 Post 请求
    - 通过引诱链接诱惑用户点击触发请求，利用 a 标签的 href。

- 关于Web密码学你了解哪些呢
    - 对称加密算法 钥匙
        - 对称加密算法就是加密和解密使用同一个密钥，简单粗暴
    - 非对称加密算法
        - 非对称加密就是加密和解密使用不同的密钥。发送方使用公钥对信息进行加密，接收方收到密文后，使用私钥进行解密。
        - 主要解决了密钥分发的难题
        - 我们常说的签名就是私钥加密
        - 常见的经典非对称加密算法有RSA、ECC和国密SM2
    - 散列算法
        - 不可逆性、鲁棒性、唯一性
        - MD5、SHA(SHA-256)、国密SM3
        - 使用时记得加盐

- HTTPS 和 HTTP 的区别：
    - http 是超文本传输协议，信息是明文传输，https 则是具有安全性的加密传输协议
    - http 基于 tcp 协议，tcp 三次握手之后即可开始 http 通信；https 是在 http 与 tcp 之间加了一个 SSL/TLS 安全层，在 tcp 握手之后，还要进行 TLS 握手，才可以开始通信。
    - http 没有身份认证，存在安全隐患；https 使用证书系统来进行身份认证，使用 https 的网站需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。
    - http 默认端口是 80，https默认端口 443

- SSL处于那一层？
    SSL：安全套接层，在 OSI 模型中处于第 5 层（会话层）
    SSL被改名为TLS（传输层安全 
    TLS 综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。
    浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”。

- HTTP + SSL(TLS) = HTTPS
    传输层安全性(TLS)
    安全套接字层(SSL)

1.客户端向服务器发起HTTPS请求,连接到服务器的443端口
2. 服务器端有一个密钥对,即公钥和私钥,是用来进行非对称加密使用的,服务器端保存着私钥,不能将其泄露,公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。