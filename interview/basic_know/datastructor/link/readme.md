[source](https://cloud.tencent.com/developer/article/1687729)
[source](https://github.com/likaia/JavaScript-test/blob/master/src/LinkedListTest/lib/CircularLinkedList.ts)

- 为什么语言中默认设置数组数据结构， 而不是链表？
    查询操作更多

- 维吾尔搭肩舞   那种数据结构？
    链表 元素与元素之间通过指针连接 
    链表中添加或删除元素只需要修改指针的指向即可，
    执行速度相比数组有得到显著的提升

- 链表 数组的区别
    1. 数组可能是最常用的一种数据结构 每种语言都实现了数组，
        元素在内存中是连续存放的 数组提供了一个非常方便的[]方法来访问其元素
    2. 链表存储有序元素的集合，链表中的元素在内存中并非连续存放，每个元素由一个存储元素本身的结点和一个指向下一个元素的指针组成，因此增加或删除链表内的元素只需要改变指针指向即可。
    各自优点
        - 元素通过指针连接，改变链表内的元素只需要找到元素改变其指针即可，因此数据需要频繁修改时，使用链表作为数据结构是最优解决方案。
        - 元素连续存放在内存中，访问元素可以直接通过元素下标来访问，因此数据需要频繁查询时，使用数组作为其数据结构是最优解决方案。

    各自缺点
        - 由于链表是通过指针连接的，我们只能直接拿到链表头部的元素，要想访问其他元素需要从头遍历整个链表才能找到我们想找的元素。因此数据需要频繁查询时，使用链表将适得其反。
        - 由于元素是连续存放在内存中的，改变数组内的元素时，需要调整其他元素的位置。因此数据需要频繁修改时，使用数组将适得其反。

- ADT
    链表尾部添加元素
        声明一个结点变量，以添加的元素为参数，生成一个结点，将生成的结点赋值给接待你变量。
        判断链表头部元素是否为null，如果为null直接将链表头部赋值为结点变量
        从链表头部开始遍历链表内的元素，直至链表的下一个元素指向null
        向null区域追加结点变量
        链表长度自增
    移除链表指定位置的元素
        判断当前要删除的位置是否为链表头部的元素，如果为链表头部元素则将当前链表头部元素指向当前链表头部元素中的next元素
        从链表头部开始遍历链表内的元素，直至找到目标结点和目标结点的上一个结点
        将目标结点元素指向目标结点的下一个结点元素
        链表长度自减，返回当前删除的元素内容
    获取链表指定位置的元素
        声明一个变量，用于接收遍历到的结点，默认值为链表头部元素。
        从链表头部开始遍历元素，遍历至要获取的元素位置。
        返回遍历到的结点数据
    链表任意位置插入元素
        声明结点变量，将当前要插入的元素作为参数生成结点，将生成的结点赋值给结点变量
        判断要插入的元素位置是否为0，将结点变量的下一个元素指向链表的头部元素，链表头部元素赋值为结点变量   
        获取要插入位置的上一个结点元素
        将结点变量的下一个元素指向目标结点
        将目标结点位置的元素赋值为结点变量
        链表长度自增，返回true
    根据元素获取该元素在链表中的位置
        声明一个变量用于接收遍历到的结点
        从链表头部开始遍历，判断当前遍历到的结点与目标结点是否相等
        如果相等，直接返回当前遍历的索引
        否则接收链表的下一个结点，继续执行遍历，直至遍历完链表中的所有元素为止
        链表的所有元素遍历完成后，仍没有发现与目标结点匹配的元素，元素不存在返回-1
        
- 说完他们的区别后，我们来看看双向链表的优点：双向链表相比普通链表多了一个指针，这个指针指向链表中元素的上一个元素，因此我们可以从链表的尾部开始遍历元素对链表进行操作，假设我们要删除链表中的某个元素，这个元素的位置靠近链表的末尾，我们就可以从链表的末尾来找这个元素，而链表只能从其头部开始找这个元素，此时双向链表的性能相比链表会有很大的提升，因为它需要遍历的元素少，时间复杂度低。
