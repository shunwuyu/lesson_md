[source](https://juejin.cn/post/6844904161872461831)

- 贪心  分治  动态规划， 共同的基础是？
    递归。
- 何为递归？
    去的过程叫“递”
    回来的过程叫“归”
    递归的本质要从计算机语言的本质说起
        js 相对于 c 语言来说  区别是？
        c 相对于 js 是低级语言， 更低级的语言？
        汇编
        - 汇编语言的特点就是没有循环嵌套
            高级语言来写的 if..else.. 也好， for/while 也好，在实际的机器指令层面来看，就是一个简单的地址跳转，跳转到特定的指令位置，类似于 goto 语句
            递， 执行完回来 归

- 递归最致命的缺点是？
    爆栈 爆的是何栈？  函数执行栈 
    如何优化？  尾递归

- 第一个递归代码
    阶乘 1.js   递是什么？ 归是什么？
    f(6) 需要拆解成 f(5) 子问题进行求解，以此类推 f(5) = n * f(4) ，也需要进一步拆分 ... 直到 f(1)，「这是递的过程。
    f(1) 解决后，依次可以解决f(2).... f(n)最后也被解决，「这是归的过程。
    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/18/17226641e33cf0db~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

- 递归的三个条件
    1. 问题可以被分解成几个子问题
    2. 问题和子问题的求解方法完全相同
    3. 递归终止条件

- 斐波那契数列何为？
    该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和
    F(0) = 0,   F(1) = 1 退出条件
    F(N) = F(N - 1) + F(N - 2) 子问题, 其中 N > 1.
    求解一样
    2.js
    如何改写成一行？
    3.js

- 复杂度分析
    时间复杂度怎么计算？
        总时间 = 子问题个数 * 解决一个子问题需要的时间
    - 空间复杂度为 O(n)
    - 时间复杂度 O(2^n)
        - 子问题个数即递归树中的节点总数 2^n
        - 解决一个子问题需要的时间，因为只有一个加法操作 fib(n-1) + fib(n-2) ，所以解决一个子问题的时间为 O(1)

        二者相乘，得出算法的时间复杂度为 O(2^n)，指数级别，裂开了呀

    面试的时候如果只写这样一种解法就 GG 

怎么解决？  
    递归是自顶向下(看上文递归树)
    以空间换时间   备忘录算法
    自底向上  动态规划  将递归改为迭代
    为了减少空间消耗，只存储两个值
        时间复杂度 O(n)
        空间复杂度 O(1)
        4.js

- [用“尾递归”优化斐波那契函数](https://juejin.cn/post/7026371899995193380)
    现在请用“尾递归”优化你的递归实现，用“ES6解构赋值”优化你的递推实现
    包含着相当多的JS知识点，尤其是它的优化过程可以看出你的基本功扎不扎实

    - 问题原因
        1. 当n非常大的时候，**递归深度**过大导致栈内存溢出，即“爆栈
        2. 第二个问题就是有相当多的**重复**计算
    
    - 尾调用
        一个函数里的最后一个动作是返回一个函数的调用结果，
        即最后一步新调用的返回值被当前函数返回

        ```
        function f(x) {
            return g(x)
        }
        ```
        不属于尾递归
        ```
        function f(x) {
            return g(x) + 1 // 先执行g(x)，最后返回g(x)的返回值+1
        }

        function f(x) {
        let ret = g(x) // 先执行了g(x)
        return ret // 最后返回g(x)的返回值
        }
        ```

    - 尾调用消除
        一个函数调用时，JS引擎会创建一个新的栈帧并将其推入调用栈顶部，用于表示该次函数调用
        当一个函数调用发生时，计算机必须“记住”调用函数的位置——返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般保存在调用栈上。
        在尾调用这种特殊情形中，计算机理论上可以不需要记住尾调用的位置，而从被调用的函数直接带着返回值返回当前函数的返回位置（相当于直接连续返回两次）

        5.js
        f(6, 0, 1) 
        = f(5, 1, 0 + 1) 
        = f(4, 1, 1 + 1) 
        = f(3, 2, 1 + 2) 
        = f(2, 3, 2 + 3)
        = f(1, 5, 3 + 5)
        = 8

    es6 默认参数