[source](https://time.geekbang.org/column/article/41913)

# 如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？
- 排序算法的复杂度起码是 O(NlogN)
    0.js 
    不能排
- 不排序能不能求第K 大元素
    借助快排思想 partition   pivot
    枢纽元素的位置
    就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。

- 除了分治还有分区
    分区操作
    第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。

    就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。

    每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？

    不过，时间复杂度就并不是 O(n) 了，而是 O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n) 不就等于 O(n) 吗？

    当 K 是比较小的常量时，比如 1、2，那最好时间复杂度确实是 O(n)；但当 K 等于 n/2 或者 n 时，这种最坏情况下的时间复杂度就是 O(n2) 了。

    

- 小规模排序 O(n^2)
- O(nlogn)  大规模数据排序  
    归并排序和快速排序
    相同点  分治算法 
- 看图
    ![](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)
- 何为分治 算法?
    分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。
- 像什么？
    分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突
    
- 递推公式是什么？
    归并排序

    递推公式：
    merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

    终止条件：
    p >= r 不用再继续分解

    不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
    如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我们就可以得到这样的递推关系式：
    T(a) = T(b) + T(c) + K
    
    K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。

    
    快排
    递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)终止条件：p >= r

    ![](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

- 归并 选择排序的区别
    1. 归并排序的处理过程是由下到上的 先处理子问题，然后再合并
    2. 而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
    3. 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。
        不如快排  每次合并操作都需要申请额外的内存空间，  空间复杂度O(n)
    4. 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。