[](https://juejin.cn/post/6844904179278823437)

堆知识点构建
- 什么是堆
- 怎样建堆
- 堆排序
- 内存堆与垃圾回收
- Top K 问题
- 中位数问题
- 面试题

- 怎样建堆
  1. 完全二叉树适用于数组存储法
  2. 从下标 1 开始
    堆其实可以用一个数组表示，给定一个节点的下标 i （i从1开始） ，那么它的父节点一定为 A[i/2] ，左子节点为 A[2i] ，右子节点为 A[2i+1]

  创建有两种方法
    1. 插入式建堆
      1.js
      时间复杂度： O(logn)，为树的高度
    2. 原地建堆
      let arr = [,1, 9, 2, 8, 3, 7, 4, 6, 5];
      1. 一种是承袭上面插入的思想，即从前往后、自下而上式堆化建堆
      2. 另一种是，从后往前、自上往下式堆化建堆
      自下而上式堆化 ：将节点与其父节点比较，如果节点大于父节点（大顶堆）或节点小于父节点（小顶堆），则节点与父节点调整位置
      自上往下式堆化 ：将节点与其左右子节点比较，如果存在左右子节点大于该节点（大顶堆）或小于该节点（小顶堆），则将子节点的最大值（大顶堆）或最小值（小顶堆）与之交换
      自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点

      

      2.js 从前往后、自下而上式堆化建堆
        ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727787c4d8e3f8e~tplv-t2oaga2asx-watermark.awebp)
      3.js 从后往前、自上而下式堆化建堆
        从后往前并不是从序列的最后一个元素开始，而是从最后一个非叶子节点开始，这是因为，叶子节点没有子节点，不需要自上而下式堆化。
        ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727787c4d776aba~tplv-t2oaga2asx-watermark.awebp)
      
- 堆排序
  堆是一棵完全二叉树，它可以使用数组存储，并且大顶堆的最大值存储在根节点（i=1）
  所以我们可以每次取大顶堆的根结点与堆的最后一个节点交换
  此时最大值放入了有效序列的最后一位，
  并且有效序列减1，有效堆依然保持完全二叉树的结构，然后堆化，
  成为新的大顶堆，重复此操作，知道有效堆的长度为 0，排序完成。
  1. 将原序列（n个）转化成一个大顶堆
  2. 设置堆的有效序列长度为 n
  3. 将堆顶元素（第一个有效序列）与最后一个子元素（最后一个有效序列）交换，并有效序列长度减1
  4. 堆化有效序列，使有效序列重新称为一个大顶堆
  5. 重复以上2步，直到有效序列的长度为 1，排序完成
  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727787c4d742609~tplv-t2oaga2asx-watermark.awebp)

  