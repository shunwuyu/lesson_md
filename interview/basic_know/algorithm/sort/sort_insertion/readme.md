[source](https://juejin.cn/post/6844903936877395982)

- 以下图为何种排序
    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d05d41c9411a33~tplv-t2oaga2asx-watermark.awebp)
    插入排序 实指把待排序元素插入到已排好的序列里。

- 如何做到有序序列里找到正确的插入位置
    从有序序列的尾部开始，逐个与目标元素比较，如果大于目标元素，该元素需要后移。
    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/6/16d060018d77a741~tplv-t2oaga2asx-watermark.awebp)


-   插入排序的优点是？
    插入排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为O(n^2)，适用于少量数据排序。相比冒泡排序和选择排序，插入排序的使用相对多一些。因为前两者是交换排序，本质上需要3次原子操作的。
    冒泡排序， 选择排序  是交换顺序的， 本质上需要3次原子操作的

- 为什么插入排序比冒泡排序更受欢迎？
    从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
    冒泡排序中数据的交换操作：
    if (a[j] > a[j+1]) { // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;}
    插入排序中数据的移动操作：
    if (a[j] > value) { a[j+1] = a[j]; // 数据移动} else { break;}

    我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

    这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，我写了一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！

    虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。
    
- 选择排序的缺点是？
    稳定性
        在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
        比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

    ![](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)