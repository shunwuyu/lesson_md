https://juejin.im/post/5e02110ee51d4557f046147b#heading-9
性能考虑 兼容性
- var arr = [1, 2, NaN];
arr.indexOf(NaN); 

- 这些就OK了嘛？
  NaN == NaN
  null == null   null === null  正则， 
   == 和 === 区别

1. 数组去重应该是面试必考问题之一。
2. 虽然它是一道并不复杂的问题，但是也能看出面试者的广度和深度，还有考虑问题的全面性。
3. 实际开发中我们应该选择哪种方式数组去重，
4. 他想知道的有点多，包括你的思想。

- 双层 for 循环   
  1. 改变长度
    时间复杂度是O(n^2)如果数组长度很大，效率会很低。
- Array.filter() 加 indexOf
- Array.sort() 加一行遍历冒泡(相邻元素去重)
  V8引擎 的 sort() 方法在数组长度小于等于10的情况下，会使用插入排序，大于10的情况下会使用快速排序
- ES6 中的 Set 去重
- Object 键值对
  obj[typeof item + item] = true没有直接使用obj[item],是因为
  因为 123 和 '123' 是不同的，直接使用前面的方法会判断为同一个值，因为对象的键值只能是字符串，所以我们可以使用 typeof item + item
- reduce 实现对象数组去重复


性能考虑

双重 for 循环 > Array.filter()加 indexOf > Array.sort() 加一行遍历冒泡 > Object 键值对去重复 > ES6中的Set去重

兼容性与场景考虑(数组中是否包含对象，NaN等？)

内存考虑(去重复过程中，是想要空间复杂度最低吗
应该 Object 对象去重复的方式是时间复杂度是最低的，除了一次遍历时间复杂度为O(n) 后，查找到重复数据的时间复杂度是O(1)，类似散列表，大家也可以使用 ES6 中的 Map 尝试实现一下。
但是对象去重复的空间复杂度是最高的，因为开辟了一个对象，其他的几种方式都没有开辟新的空间，从外表看来，更深入的源码有待探究，这里只是要说明大家在回答的时候也可以考虑到时间复杂度还有空间复杂度。

有的小伙伴会认为 Array.filter()加 indexOf 这种方式时间复杂度为 O(n) ,其实不是这样，我觉得也是O(n^2)。因为 indexOf 函数，源码其实它也是进行 for 循环遍历的。具体实现如下

当数组长度大于等于 200 时，会创建 Set并将 Set 转换为数组来进行去重（Set 不存在情况的实现不做分析）。当数组长度小于 200 时，会使用类似前面提到的 双重循环 的去重方案，另外还会做 NaN 的去重。


