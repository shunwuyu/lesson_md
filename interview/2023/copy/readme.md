- 1.js
    把拷贝和赋值搞混了
- 拷贝和赋值的区别
    1. 浅拷贝：
        如图
        创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
    2. 深拷贝：
        将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象



- 乞丐版  用的最多
    JSON.parse(JSON.stringify());  
    缺陷 拷贝函数、循环引用、拷贝其他引用类型
    面试时你只说出这样的方法是一定不会合格的

- 向面试官展示什么？
    1. 用递归解决问题

- 基础版本
    1. 浅拷贝
        function clone(target) {
    let cloneTarget = {};
    for (const key in target) {
        cloneTarget[key] = target[key];
    }
    return cloneTarget;
};

1. 多少层深度  递归
    如果是原始类型，无需继续拷贝，直接返回
    如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。

2. 因为递归进入死循环导致栈内存溢出了。  target: [Circular *1]   es6
    我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。
    需要可以存储key-value形式的数据，且key可以是一个引用类型，我们可以选择Map这种数据结构：
    - 检查map中有无克隆过的对象
    - 有 - 直接返回
    - 没有 - 将当前对象作为key，克隆对象作为value进行存储
    - 继续克隆

3. WeakMap提代Map来使代码达到画龙点睛的作用。
    

1. 浅拷贝，拷贝的是对象的指针，修改内容互相影响
2. 深拷贝， 整个对象拷贝到另一个对象中， 修改内容互补影响

- 你真的理解什么是深拷贝吗？
- 在面试官眼里，什么样的深拷贝才算合格？
- 什么样的深拷贝能让面试官感到惊艳？


