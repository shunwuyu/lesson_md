动态规划的关键特征
    1. 要求你给出达成某个目的的解法个数（最值 大  小）
        爬楼梯
        斐波那契
        凑硬币问题
        打家劫舍问题
        最长斐波那契子序列问题
    2. 不要求你给出每一种解法对应的具体路径

    套路
    1. 递归思想分析问题    倒着分析问题
        定位到问题的终点 f(n)
        站在终点这个视角，思考后退的可能性  f(n) = f(n-1) + f(n-2)   状态转移方程   

    2. 树状结构
        递归
    3. 备忘录 
    4. 自底向上  动态规划


1. 斐波那契  2-4.js  
    暴力， 备忘录 动态规划
    
2. 凑硬币问题
    https://juejin.cn/book/6844733800300150797/section/6844733800367276039
    倒推   11    10  9  6  可能到达  
        f(36) = Math.min(f(36-c1)+1,f(36-c2)+1,f(36-c3)+1......f(36-cn)+1)
    递归的边界条件  0  f[0]

3. 打家劫舍问题
    https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fhouse-robber%2F
    https://leetcode.cn/problems/house-robber/
    老套路
    1. dp[i]是什么？ 在不触犯警报的情况下，偷到的最大金额数，那么dp[i]就代表从截止到第i个房子，最大的金额数。
    2. 变量初始化
        房子数目为1 dp[0]=nums[0]
        假如房子数目为2  dp[1]=max(nums[0],nums[1])
    3. 规律总结
        从第三个数开始，dp[i]是不是满足
        看图
        拿或者不拿
        dp[i]=max(dp[i−2]+nums[i],dp[i−1])关系式

4. 最长斐波那契数列
    https://leetcode.cn/problems/Q91FMA/
    1.js
    - 朴素解法(暴力)
        先确定两个元素，在按照斐波那契数列计算规则，计算下一个数值，如果下一个数值在给出的数组中，则长度至少为3。在查找元素的时候，我们可以使用 hashMap 数据结构，提升查询效率。
    -   在朴素解法中，由于是双重循环遍历，有多余的重复计算。为了提升计算效率，我们可以采用记忆化的方式，缓存之前计算的结果
        二维
        dp[k][j] 是什么？ 第k 和第j个数能不能组成斐波那契数列？ 
            arr[j]-arr[k]  是否在字典中，  [map.get(f1)][k]  与  arr[k] 斐波那契额后+1 
        - 变量初始化  都为 2  
        - 规律总结
        dp[k][j] = Math.max(dp[map.get(f1)][k] + 1, dp[k][j])

5. 背包问题
    有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？
    注意：每种物品都只有1件

    - 暴力枚举法
        考虑到每一种物品都面临“放”和“不放”两种选择，因此 n 个物品就对应 2^n 种情况，进而会带来高达 O(2^n)的时间复杂度
    - 最值 
        如何才能使背包内的物品总价值最大 
    - 倒推法明确状态间关系
        1. 假设背包已满，容量已经达到了 c
        2. 站在c这个容量终点往后退，考虑从中取出一样物品，那么可能被取出的物品就有 i 种可能性
        3. 我们现在尝试表达“取出一件”这个动作对应的变化，我用 f(i, c)
            第 i 件物品在背包里
            f(i, c) - value[i] = f(i-1, c-w[i]) 
            f(i, c) = f(i-1, c-w[i]) + value[i] 最优子结构
            第 i 件物品不在背包里
                f(i, c) = f(i-1, c)

            dp[i][v] = Math.max(dp[i-1][v], dp[i-1][v-w[i]] + c[i])

            
- 最长回文子串
    https://github.com/azl397985856/leetcode/blob/master/problems/5.longest-palindromic-substring.md

    “延伸”
    子问题
    如果在一个不是回文字符串的字符串两端添加任何字符， 或者在回文串左右分别加不同的字符，得到的一定不是回文串
    一个字符
    两个相等字符
    大问题和小问题之间的关联，基于此，我们可以建立动态规划模型。
    dp[i][j]  s中从i j   是否可以形成回文

- 买卖股票
    https://juejin.cn/post/7150606313578299405
    我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）
    10.js
    9.js
    第i天的最大收益只需要知道前i天的最低点就可以算出来了。而第i天以前（包括第i天）的最低点和i-1天的最低点有关，至此我们的动态方程就出来了

    dp[i] = min(dp[i-1], prices[i])  dp[0]=prices[0],






        




