[source](https://juejin.cn/book/6844733800300150797/section/6844733800346288142?scrollMenuIndex=0)

- 不撞南墙不回头， 指什么算法？
    深度优先搜索思想

- 请表达如图二叉树
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};

- 如何遍历一个数组？ 链表？
    下标迭代  指针， 简单

- 二叉树呢？
    难度大
    经常考的先序， 中序， 后序来了？ 还有呢？
    层序遍历

- 方法：
    手写
    在理解的基础上记忆

- 递归遍历
    先，中，后序遍历
- 迭代遍历
    层次遍历

- 命中了那两个热点？
    二叉树和“递归”

- 递归的概念
    函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。

    - 反复
        一个函数反复调用它自己的时候，递归就发生了
        递归”就意味着“反复”
        二叉树定义
            - 它可以没有根结点，作为一棵空树存在
            - 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树
            意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止

每一棵二叉树都应该由这三部分组成
对树的遍历，就可以看做是对这三个部分的遍历
左子树一定先于右子树遍历
根结点 -> 左子树 -> 右子树 先序遍历
左子树 -> 根结点 -> 右子树 中序遍历
左子树 -> 右子树 -> 根结点 后序遍历
根结点的遍历分别被安排在了首要位置、中间位置和最后位置

这个“重复”，我们就用递归来实现

- 递归函数的编写要点
    - 递归式
        你每一次重复的内容是什么
        根结点 -> 左子树 -> 右子树
    - 递归边界
        你什么时候停下来
        在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界

    
- 两种关键的基本算法思想：
    - DFS 深度优先搜索
    - BFS广度优先搜索
    - 与什么相关？
        栈和队列
    
- 按照这个思路走下去，只要迷宫是有出口的，你就一定能找到这个出口。

- 深度优先
    我们贯彻了“不撞南墙不回头”的原则：只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——像这样将“深度”作为前进的第一要素的搜索方法，就是所谓的“深度优先搜索”。

    深度优先搜索的核心思想，是试图穷举所有的完整路径。

- 能总结出， 他的本质吗？
    栈结构

二叉树的先序遍历正是深度优先搜索思想的递归实现
    