https://juejin.cn/post/7142690757722243102#heading-27

- console.log(typeof typeof typeof null);
    1.js

- 为什么小程序里拿不到dom相关的api
    小程序是一种跨平台的应用程序, 它的运行环境是一个轻量级的沙箱，主要基于 WebView 实现，限制了对于部分系统 API 的访问权限，包括 DOM 相关的 API。

    虽然小程序中不能直接使用 DOM 相关的 API，但小程序提供了类似 DOM 的结构和操作方式，比如 WXML 和 WXSS，可以方便地实现页面布局和样式设置，同时也提供了一些类似于 DOM 的操作方式，例如通过 wx.createCanvasContext 创建画布上下文进行画图等操作

- 3.js  this 指向
    普通函数 123

- LRU 算法 Least Recently Used  最近最少使用
    当缓存满时，将最近最少使用的缓存页替换成新页面。

    4.js

- Promise then 第二个参数和catch的区别是什么
    7.js

- finally
    10.js
    .finally()方法没有参数，返回值为一个.then()方法，从而允许我们接着在链式调用中使用
    如关闭文件或释放资源

- 作用域链
    11.js 代码表达了js 的什么概念?
    作用域链（Scope Chain）是 JavaScript 中一个重要的概念，用于描述变量查找的规则
    当 JavaScript 执行某段代码时，它会先在当前作用域中查找变量。如果没有找到，就会向
    上一级作用域中继续查找，直到找到该变量或者到达全局作用域为止。这条从当前作用域到全局作用域的链，就叫做作用域链。作用域链的形成是由函数的创建时决定的。每当一个函数被创建，它的作用域链就被初始化为当前执行上下文中的变量对象，然后将该函数的父级函数的变量对象添加到作用域链的顶层。当函数执行结束后，它的作用域链也会随之销毁

    作用域链的重要性体现在以下两个方面：
    变量的查找
    变量的保护
    VO AO 对象分别是？
    VO，全称为 Variable Object，变量对象。每个函数在执行之前，都会创建一个变量对象（VO），用于存储该函数内部声明的变量、函数声明以及函数的形参等信息。这个变量对象在函数执行完毕后会被销毁。VO 一般包括以下属性：

    Arguments：包含该函数的所有参数的对象。

    Function：如果该函数是函数声明，则把整个函数对象保存在这个属性中。

    Variable：包含该函数内部所有声明的变量（但不包括函数参数）

    AO，全称为 Activation Object，执行期上下文的活动对象。在函数开始执行时，JavaScript 引擎首先会创建一个执行期上下文（Execution Context），然后根据函数的作用域链创建一个 AO，用于存储函数的执行期变量、函数、参数和 this 等信息。在函数执行完毕后，这个 AO 也会被销毁。AO 一般包括以下属性：

    Arguments：包含该函数的所有传入参数。

    Function：如果该函数是函数声明，则把整个函数对象保存在这个属性中。

    Variable：包含该函数执行期间创建的所有变量和函数。

    它们两个的区别在于 VO 是在函数执行之前创建的，用于存储函数内部声明的变量、函数声明和函数的形参信息。而 AO 是在函数执行期间动态创建的，用于存储函数内部声明的变量、函数声明、函数的形参和 this，以及执行期间创建的其他变量和函数。VO 是静态的，不会随着函数的执行环境而改变，而 AO 是动态的，它的具体内容取决于函数每次执行时的执行上下文。

需要注意的是，VO 和 AO 并不是 ECMAScript 标准中的术语，而是对其内部实现的描述。在不同的 JavaScript 引擎中，VO 和 AO 的实现可能有所不同，但它们都是用于实现 JavaScript 作用域和闭包的重要机制。
    


- webworker
    1. 在主线程中创建 Worker 对象，并指定 JavaScript 文件路径。
    2. 在主线程中为 Worker 对象添加 message 事件监听器，接收 Worker 发送的消息。
    3. 在 Worker 中为 self 对象添加 message 事件监听器，接收主线程发送的消息。
    4. 在 Worker 中处理接收到的消息，并通过 postMessage() 方法将处理结果返回给主线程。

    Web Worker 和主线程是彼此独立的线程，它们之间无法共享变量和函数。Web Worker 只能通过 postMessage() 方法向主线程发送消息，而主线程只能通过 Worker.postMessage() 方法向 Web Worker 发送消息。这意味着在 Web Worker 中无法访问 DOM 和 BOM，也不能使用 alert() 和 console.log() 等方法。

    