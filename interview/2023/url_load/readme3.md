- ```
    console.log('a')
    console.log('b')
```
    JS执行是需要分号的，但为什么以下语句却可以正常运行呢

- 聊聊图 有什么意义

- JS脚本如何执行？  
    引擎解析
- 分成那几个阶段？
    解释阶段
    预处理阶段
    执行阶段
    回收机制

- 何为解释阶段？
     JS是解释型语音，所以它无需提前编译，而是由解释器实时运行
     - 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）
     - 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）
    -  使用翻译器（translator），将代码转为字节码（bytecode）
        运行时编译 JIT-Just In Time compiler 用到哪一行就编译哪一行，并且把编译结果缓存 核心的JIT编译器将源码编译成机器码运行
        chrome的v8 省略了字节码的翻译步骤
    - 使用字节码解释器（bytecode interpreter），将字节码转为机器码
- JS的预处理阶段
    在正式执行JS前，还会有一个预处理阶段（变量提升，分号补全）
    目的： 为确保JS可以正确执行， 会做一些事情
    1. 分号补全
    ```
    console.log('a')
    console.log('b')
    ```
    JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号
    - 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。
    - 当有}时，如果缺少分号，会补分号。
    - 程序源代码结束时，如果缺少分号，会补分号。
    1.js  运行结果是什么？
    - 变量提升
        函数提升和变量提升
        let 暂时死区
        2.js
- JS的执行阶段
    - 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
        - JS有执行上下文
        - 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶
        - 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
        - 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
        - 这样依次执行（最终都会回到全局执行上下文）

        如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收

        每一个执行上下文，都有三个重要属性：
    - VO（变量对象）和AO（活动对象）
        - 变量对象(Variable object，VO)
            vars  function declarations  arguments
        - 作用域链(Scope chain)
        - this
    - 作用域链
        Variable object + all parent scopes
        在函数上下文中，查找一个变量foo
        如果函数的VO中找到了，就直接使用
        否则去它的父级作用域链中（__parent__）找
        如果父级中没找到，继续往上找
        直到全局上下文中也没找到就报错
    - this机制等
        Context Object 
        this是执行上下文环境的一个属性，而不是某个变量对象的属性
        3.js

- VO与AO
    VO是执行上下文的属性（抽象概念）只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）
    AO（activation object)，当函数被调用者激活，AO就被创建了
    在函数上下文中：VO === AO
    在全局上下文中：VO === this === global

- 回收机制
    JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理
    譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）
    两种垃圾回收规则是？
    - 标记清除
        - 遍历所有可访问的对象。
        - 回收已不可访问的对象。
        当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
        从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
        而当变量离开环境时，则将其标记为“离开环境”。
        垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）
        然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
        而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
        最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
    - 引用计数
        跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）