[source](https://juejin.cn/post/6844903574535667719)

- 如何由一道题展示自己的前端知识体系！
    从输入URL到页面显示过程
    - 覆盖面可以非常广
    - 前端知识体系

- 怎么回答？
    搜索
    不借助搜索引擎，自己的心里是否有一个答案

- 一下回答
    - 浏览器发起请求，服务端返回数据，然后前端解析成网页，执行脚本
        - 浏览器输入url后会有http请求这个概念
        - 有后台这个概念，大致知道前后端的交互，知道前后端只要靠http报文通信
        - 知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉
            render树构建流程 layout、 paint 常用优化方案等不是很熟悉
        - 对于js引擎的解析流程有一定概念，但是细节不熟悉
            形参，函数，变量提升，执行上下文 作用域链，回收机制等概念不是很熟悉
        - 如可能知道一些http规范初步概念，但是不熟悉
            http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉

- 知识体系如此重要
    visibility: hidden和display: none的区别
    普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置
    进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大
    再进一步，当一个页面某个元素经常需要切换display时如何优化，用absolute让其脱离普通文档流也行。
    如何理解getComputedStyle
        在尚未梳理知识体系前，大概会这样回答：普通版本：getComputedStyle会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过window.getComputedStyle等价于document.defaultView.getComputedStyle调用

        详细版本：window.getComputedStyle(elem, null).getPropertyValue("height")可能的值为100px，而且，就算是css上写的是inherit，getComputedStyle也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。
        - getComputedStyle会获取当前元素所有最终使用的CSS属性值
        - getComputedStyle会引起回流 因为它需要获取祖先节点的一些信息进行计算 
            所以用的时候慎用，回流会引起性能问题。

回到这道题上，如何回答呢？先梳理一个骨架
    1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
        浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）
        进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等
        1、浏览器进程

    主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。

    2、渲染进程

    核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。此进程包括了GUI线程、javascript解析引擎、事件触发线程。

    3、GPU进程

    GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。

    4、网络进程

    主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。

    5、插件进程

    主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
    多线程的浏览器内核
        每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程
            - GUI线程
            - JS引擎线程
            - 事件触发线程
            - 定时器线程
            - 网络请求线程
    可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的
    解析URL
        输入URL后，会进行解析（URL的本质就是统一资源定位符）
        URL一般包括几大部分：

            protocol，协议头，譬如有http，ftp等

            host，主机域名或IP地址

            port，端口号

            path，目录路径

            query，即查询参数

            fragment，即#后的hash值，一般用来定位到某个位置

    网络请求都是单独的线程
每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载

因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源

    开启网络线程到发出一个完整的http请求
        这一部分主要内容包括：dns查询，tcp/ip请求构建，五层因特网协议栈等等
        DNS查询得到IP
        如果输入的是域名，需要进行dns解析成IP，大致流程：
            如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
            如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP
            域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）
            需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化

            在firefox上使用dns-prefetch，dns预解析是与页面加载是并行处理的，且不用影响到页面加载的性能.

            在以图片为主移动网站被访问时，在使用DNS预解析的情意中下，页面加载时间可以提升%5个点   
            <link rel="dns-prefetch" href="http://img.jb51.net" /> 掘金

    tcp/ip请求
        http的本质就是tcp/ip请求
        需要了解3次握手规则建立连接以及断开连接时的四次挥手
        tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输
        三次握手的步骤：
        客户端：hello，你是server么？
        服务端：hello，我是server，你是client么
        客户端：yes，我是client 
        建立连接成功后，接下来就正式传输数据

        然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）
        主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
        被动方：收到通道关闭的信息
        被动方：那我也告诉你，我这边向你的主动通道也关闭了
        主动方：最后收到数据，之后双方无法通信

        三元的图
        从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。
然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。
服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。
之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。
另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:

凡是需要对端确认的，一定消耗TCP报文的序列号。

SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。

    为什么不是两次？
    无法确认客户端的接收能力。

    如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。
看到问题的吧，这就带来了连接资源的浪费。

    为什么不是四次？
三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？

当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

    三次握手过程中可以携带数据么？
第三次握手的时候，可以携带。前两次握手不能携带数据。
如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能

tcp/ip的并发限制
    浏览器对同一域名下并发的tcp连接是有限制的 2-10个不等
    而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求 1.1 变化了
    所以针对这个瓶颈，又出现了很多的资源优化方案

get和post的区别
    get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。
    get会产生一个tcp数据包，post两个
    - get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），
    - post请求时，浏览器先发送headers，服务器响应100 continue， 浏览器再发送data，服务器响应200（返回数据）。

五层因特网协议栈
    从客户端发出http请求到服务器接收，中间会经过一系列的流程。
    从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

    1. 应用层(dns,http) DNS解析成IP并发送http请求
    2. 传输层(tcp,udp) 建立tcp连接（三次握手）
    3. 网络层(IP,ARP) IP寻址
    4. 数据链路层(PPP) 封装成帧
    5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

    其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。
    OSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

    表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

    会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程




    2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
    3.  从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
        负载均衡
        对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡
        用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户

    后台的处理
        先是服务器接受到请求
        对应的后台程序接收到请求端口
        后台会有自己的统一处理，处理完后响应响应结果

    4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
        前后端交互时，http报文作为信息的载体
        报文一般包括了：通用头部，请求/响应头部，请求/响应体

        通用头部
            这也是开发人员见过的最多的信息，包括如下：
            Request Url: 请求的web服务器地址

            Request Method: 请求方式
            （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）

            Status Code: 请求的返回状态码，如200代表成功

            Remote Address: 请求的远程服务器地址（会转为IP）

            200——表明该请求被成功地完成，所请求的资源发送回客户端
            304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
            400——客户端请求有错（譬如可以是安全模块拦截）
            401——请求未经授权
            403——禁止访问（譬如可以是未登录时禁止）
            404——资源未找到
            500——服务器内部错误
            503——服务不可用

            1xx——指示信息，表示请求已接收，继续处理
            2xx——成功，表示请求已被成功接收、理解、接受
            3xx——重定向，要完成请求必须进行更进一步的操作
            4xx——客户端错误，请求有语法错误或请求无法实现
            5xx——服务器端错误，服务器未能实现合法的请求

        当请求出错时，状态码能帮助快速定位问题

        Accept: 接收类型，表示浏览器支持的MIME类型
（对标服务端返回的Content-Type）
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
Content-Type：客户端发送出去实体内容的类型
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
Cookie: 有cookie并且同域访问时会自动带上
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
Host：请求的服务器URL
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
User-Agent：用户客户端的一些必要信息，如UA头部等

    Access-Control-Allow-Headers: 服务器端允许的请求Headers
    Access-Control-Allow-Methods: 服务器端允许的请求方法
    Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
    Content-Type：服务端返回的实体内容的类型
    Date：数据从服务器发送的时间
    Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
    Last-Modified：请求资源的最后修改时间
    Expires：应该在什么时候认为文档已经过期,从而不再缓存它
    Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
    ETag：请求变量的实体标签的当前值
    Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
    Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
    Server：服务器的一些相关信息





    5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）
    6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
    7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
    8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
    9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）