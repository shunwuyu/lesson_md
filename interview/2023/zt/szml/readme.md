- react ts的泛型
    https://juejin.cn/post/7064351631072526350
    -泛型，是 TS 最难理解的部分，拿下了泛型，TS 就没什么难的了。
    ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ee9a28c9e804336a3773de1b9ce6261~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

- 输入网址后到出现界面浏览器做了哪些工作
    https://juejin.cn/post/6844904132071915527
    https://juejin.cn/post/6844904134307495943
    当输入一个URL拿到了页面后，浏览器怎么解析 怎么呈现
    - 线程/进程概念及区别
        CPU是计算机的核心，承担所有的计算任务
        进程是CPU资源分配的最小单位
        字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序
        进程包括运行中的程序和程序所使用到的内存和系统资源
        CPU 可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个 进程 ，为什么电脑运行的软件多就会卡，是因为 CPU 给每个 进程 分配资源空间，但是一个 CPU 一共就那么多资源，分出去越多，越卡，每个进程之间是相互独立的， CPU 在运行一个 进程 时，其他的进程处于非运行状态，CPU 使用 时间片轮转调度算法 来实现同时运行多个进程
        
        线程 是 CPU 调度的最小单位
        线程 是建立在 进程 的基础上的一次程序运行单位，通俗点解释 线程 就是程序中的一个执行流，一个 进程 可以有多个 线程
        一个 进程 中只有一个执行流称作 单线程 ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行
        一个 进程 中有多个执行流称作 多线程，即在一个程序中可以同时运行多个不同的 线程 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 线程 来完成各自的任务
        # 进程和线程的区别
          进程是操作系统分配资源的最小单位，线程是程序执行的最小单位
          一个 进程 由一个或多个 线程 组成，线程 可以理解为是一个进程中代码的不同执行路线
          进程 之间相互独立，但同一进程下的各个 线程 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)
          调度和切换：线程上下文切换比进程上下文切换要快得多  

    - 多线程/多进程概念
        多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰
        多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务
        JS为什么是单线程
        JS的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题
        假定 JavaScript 同时有两个线程，
        一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
        还有人说 js 还有 Worker 线程，对的，为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许 JavaScript 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作DOM
        所以，这个标准并没有改变JavaScript是单线程的本质


    - 浏览器的主要进程
        浏览器是多进程的，拿 Chrome 来说，我们每打开一个Tab页就会产生一个进程，我们使用 Chrome 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗CPU
        ## 浏览器包含哪些进程
            1. Browser进程
                - 浏览器的主进程(负责协调、主控)，该进程只有一个
                - 负责浏览器界面显示，与用户交互。如前进，后退等
                - 负责各个页面的管理，创建和销毁其他进程
                - 将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上
                - 网络资源的管理，下载等
            2. 第三方插件进程 多个  
                每种类型的插件对应一个进程，当使用该插件时才创建
            3. GPU进程
                该进程也只有一个，用于3D/动画绘制等等
            4. 渲染进程
                即通常所说的浏览器内核(Renderer进程，内部是多线程)
                每个Tab页面都有一个渲染进程，互不影响
                主要作用为页面渲染，脚本执行，事件处理等
        ## 为什么浏览器要多进程
            我们假设浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差
            同理如果插件崩溃了也会影响整个浏览器
            浏览器进程有很多，每个进程又有很多线程，都会占用内存

            这也意味着内存等资源消耗会很大，有点拿空间换时间的意思
            到此可不只是为了让我们理解为何Chrome运行时间长了电脑会卡，
        ## 简述渲染进程Renderer
            页面的渲染，JS的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程
            渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程
            GUI渲染线程
            负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等

            解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree
            解析css，生成CSSOM(CSS规则树)
            把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)
            当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)
            当我们修改元素的尺寸，页面就会回流(Reflow)
            页面需要Repaing和Reflow时GUI线程执行，绘制页面
            回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint
            GUI渲染线程与JS引擎线程是互斥的
                当JS引擎执行时GUI线程会被挂起
                GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行
        ## JS引擎线程
            - JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)
            - JS引擎线程负责解析Javascript脚本，运行代码
            - JS引擎一直等待着任务队列中任务的到来，然后加以处理
                - 浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的
                - 一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序
            - GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程
                - 就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)
                - 例如浏览器渲染的时候遇到script标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况
        ## 事件触发线程
            - 属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列
            - 当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。
            - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
            - 因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理

        ## 定时触发器线程
            setInterval 与 setTimeout 所在线程
            - 浏览器定时计数器并不是由JavaScript引擎计数的 (因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)
            - 通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程
            - W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms
        ## 异步http请求线程
            - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
            - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行
            - 简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行
            


    - 浏览器为什么是多进程
    - 渲染进程Renderer的主要线程
        - GUI渲染线程
        - JS引擎线程
        - 事件触发线程
        - 定时触发线程
        - 异步http请求线程
    - 渲染进程的各个线程之间关系及配合

    https://juejin.cn/post/6844904155077672968
- 谈谈http1和http2 
    https://juejin.cn/post/7079936383925616653
    即将完成使命的HTTP/1、正在向我们走来的HTTP/2、未来的HTTP/3
    1. HTTP 是浏览器与服务端最主要的通信协议
        1991 HTTP/0.9
        协议定义了客户端发起请求、服务端响应请求的通信模式。所以当时的请求报文只有一行：
        GET + 请求的文件路径
        服务端在收到请求后会返回一个以 ASCII 字符流编码的 HTML 文档。
        流程
            - 客户端和服务端建立TCP连接。
            - 客户端发送GET请求到服务端，请求index.html页面的数据。
            - 服务端发送完响应，关闭TCP连接。
        特点： 简单，一个请求需要一个连接。
        HTTP/0.9 虽然简单，但是它充分验证了 Web 服务的可行性
        - 首先它只有一个命令GET。
        - 它没有HEADER等描述数据的信息。因为这个时候的请求非常简单，它需要达到的目的也非常简单，没有那么多数据格式。
        - 服务器发送完内容之后，就关闭TCP连接。这里需要注意一点，这里的TCP连接和http请求是不一样的。http请求和TCP连接不是一个概念。一个http请求通过TCP连接发送，而一个TCP连接里面可以发送很多个http请求（HTTP/0.9不能这么做，但是HTTP/1.1可以这么做，而且在HTTP/2这方面会更大程度地优化，来提高HTTP协议传输的效率以及服务器的性能）

        1996 HTTP/1.0
        随着互联网的发展，之前的HTTP/0.9已经无法满足用户需求了，浏览器希望通过HTTP来传输脚本、样式、图片、音视频等不同类型的文件，所以在1996年HTTP进行了一次版本更新：
        - 增加了HEAD、POST等新方法
        - 增加了响应状态码，标记可能的错误原因
        - 引入了协议版本号概念
        - 引入了HTTP header的概念，让HTTP处理请求和响应更加灵活
        - 传输的数据不再局限于文本

        HTTP/1.0最主要的缺点还是跟HTTP/0.9一样，每一个TCP连接只能发送一个HTTP请求，服务器发送完响应，就关闭连接。如果后面需要请求新的数据，则需要再次建立TCP连接，但是TCP建立连接的三次握手成本比较高，并且TCP连接初始的时候发送数据的速度相对较慢，有一个慢启动和拥塞避免的阶段。极端情况，如果每次请求的数据很少，但是请求很频繁，这样每次请求很少的数据都需要建立连接然后断开。

        在1.0版本使用了一个非标准的Connection头部字段。当客户端再请求头部信息里面带上Connection：keep-alive的时候，服务器在发送完响应数据之后，就不会断开TCP连接了，从而达到复用同一个TCP连接的目的。但是由于不是标准字段，不同的实现可能导致表现得不一致，因此不能从根本上解决这个问题。
        
        HTTP/1.0最核心的改变是增加了头部设定，头部内容以键值对的形式设置。请求头部通过 Accept 字段来告诉服务端可以接收的文件类型，响应头部再通过 Content-Type 字段来告诉浏览器返回文件的类型。头部字段不仅用于解决不同类型文件传输的问题，也可以实现其他很多功能如缓存、认证信息等。
        HTTP/1.0 并不是一个“标准”，只是一份参考文档，不具有实际的约束力。
       
       1999 HTTP/1.1
        HTTP/1.0也无法满足用户需求了，最根本的问题就是链接问题，
        HTTP/1.0 每进行一次通信，都需要经历建立连接、传输数据和断开连接三个阶段。当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量网络开销。
        1. 长连接：引入了 TCP 连接复用，即一个 TCP 默认不关闭，可以被多个请求复用
        2. 并发连接：对一个域名的请求允许分配多个长连接（缓解了长连接中的「队头阻塞」问题）
        3. 引入管道机制（pipelining），一个 TCP 连接，可以同时发送多个请求。（响应的顺序必须和请求的顺序一致，因此不常用）
        4. 增加了 PUT、DELETE、OPTIONS、PATCH 等新的方法
        5. 新增了一些缓存的字段（If-Modified-Since, If-None-Match）
        6. 请求头中引入了 range 字段，支持断点续传
        7. 允许响应数据分块（chunked），利于传输大文件
        8. 强制要求 Host 头，让互联网主机托管称为可能
        HTTP管道机制（pipelining）
它指的是在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能 够区分出每次请求的响应内容。

        ，HTTP 1.1 还是暴露出一些局限性:
        - 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力
        - pipeling 只部分解决了队头阻塞（ HOLB）。 HTTP 1.1 尝试使用 pipeling 来解决队头阻塞问题，即浏览器可以一次性发出多个请求（同个域名、同一条 TCP 链接）。 但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。

        - 协议开销大，没有相应的压缩传输优化方案。 HTTP/1.1 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。

        HTTP/1.1 通过长连接减少了大量创建/断开连接造成的性能消耗，但是它的并发能力受到限制，表现在两个方面：

        - HTTP/1.1 中使用持久连接时，一个连接中同一时刻只能处理一个请求。当前的请求没有结束之前，其他的请求只能处于阻塞状态，这种情况被称为队头阻塞
        - 浏览器为了减轻服务器的压力，限制了同一个域名下的 HTTP 连接数，一般为 6 ~ 8 个。为了解决数量限制，出现了 域名分片 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等。
    SPDY：HTTP1.X的优化（改进版HTTP/1.1）
        1. 降低延迟： 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。
请求优先级（request prioritization）：多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
header压缩：前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
基于HTTPS的加密协议传输：大大提高了传输数据的可靠性。
服务端推送（server push）：可以让服务端主动把资源文件推送给客户端。当然客户端也有权

        2015 HTTP/2.0
        2015 年正式发布的 HTTP/2 默认不再使用 ASCII 编码传输，而是改为二进制数据，来提升传输效率
        客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧（Frame），然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。
        有了二进制分帧后，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，这种利用一个连接来发送多个请求的方式称为多路复用。每一条路都被称为一个 stream（流）
        二进制协议： HTTP/1.1版本的头部信息是文本，数据部分可以是文本也可以是二进制。HTTP/2版本的头部和数据部分都是二进制，且统称为‘帧’


多路复用： 废弃了 HTTP/1.1 中的管道，同一个TCP连接里面，客户端和服务器可以同时发送多个请求和多个响应，并且不用按照顺序来。由于服务器不用按顺序来处理响应，所以避免了“对头堵塞”的问题。


头部信息压缩： 使用专用算法压缩头部，减少数据传输量，主要是通过服务端和客户端同时维护一张头部信息表，所有的头部信息在表里面都会有对应的记录，并且会有一个索引号，这样后面只需要发送索引号即可


服务端主动推送： 允许服务器主动向客户推送数据


数据流： 由于HTTP/2版本的数据包不是按照顺序发送的，同一个TCP连接里面相连的两个数据包可能是属于不同的响应，因此，必须要有一种方法来区分每一个数据包属于哪个响应。HTTP/2版本中，每个请求或者响应的所有数据包，称为一个数据流（stream），并且每一个数据流都有一个唯一的编号ID，请求数据流的编号ID为奇数，响应数据流的编号ID为偶数。每个数据包在发送的时候带上对应数据流的编号ID，这样服务器和客户端就能分区是属于哪一个数据流。最后，客户端还能指定数据流的优先级，优先级越高，服务器会越快做出响应。

        2018 HTTP/3.0
    
- 为什么useState返回的是一个数组
    https://juejin.cn/post/6992562102007234567

- 描述一下你的项目
    1. 发现你简历的一个项目，直接让你介绍下这个项目
    2. 这类跟项目相关的综合性问题，既能体现候选人的代码水平、业务能力，也能够辨别候选人是不是真的做过项目，还能够发现候选人的一些软技能。
    3. 即要体现技术难度，又要想好细节。
        1. 该项目使用react全家桶开发，全面使用hooks 函数式组件编程，
            仿了XXX应用， 为了熟悉react全家桶开发
        2. 项目架构及目录，借鉴了网上优质的开源项目，非常清晰
            src/ 为开发目录
            /pages  页面级别路由
            /components 组件
            /assets  静态资源
            /api    接口
            /utils   工具函数封装
            /routes  路由
            /store redux
        - 样式开发全面解决 reset  font   theme 及样式组件
            - 使用styled-components GlobalStyle 全局声明reset  自定义字体 和主题
            - 使用styled-components实现样式模块化， 不污染全局，同时实现样式组件复用
        - 使用better-scroll 实现组件滚动， 滚到底部加载等
        - 路由懒加载 lazy + suspense  页面级别组件 使用函数化引入， 这样在首页时， 不需要加载不需要的组件， 加速页面打开速度， 路由切换时， 加载相应组件
        - redux 采用了清晰的命名风格， 提升了可读性。
            比如在组件connect 中 取名  getRankListDataDispatch
            在action中  getRankList
            api  getRankListRequest 
        - 接口请求采用axios 配置baseURL  添加拦截
            - 比如在用jwt做登陆，拿到后端返回的token，存到localStorage 后，
                在axios 请求拦截中， 添加Authorization 头部字段， 带上 token
            - axios 默认会给返回数据， 外层包data, 响应拦截做了解构
        - 使用了react-lazyload  实现图片懒加载
        - 采用了swiper 实现幻灯片， 由于swiper 工作， 需要用到DOM 节点。
            useRef 绑定ref , 得到节点， 完成swiper 
        - 采用react-transition-group 给页面切换 过度动画
            CSSTransition 会给指定的类名 比如 fade 添加不同生命周期类名，做为过渡动画钩子
            fade-enter(立即)   fade-enter-active（很快时间，持续）
            fade-exit-active(很快， 持续)  fade-exit(最后)
            active 写transition  
        - 接口数据尝试过  fastmock   
            mockjs  
            koa 自建接口
        - 后端接口使用koa-cors  cors 中间件， 解决跨域问题
        - 借鉴ahooks 封装了  useRequest  把数据请求 loading 状态， 出错， 封装成自定义hook
        - React.memo（props） + useCallback（缓存函数） 性能优化
            省去不必要的渲染
        - React.memo  + useMemo (缓存计算的结果)
            搜索组件中使用useMemo 缓存 截流处理搜索的函数
            不用在每次组件跟新 重新运行时 重新计算
