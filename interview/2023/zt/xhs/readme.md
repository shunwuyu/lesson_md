1. 组件通信方式
    - 以函数组件为讨论基准, 使用 React Hook 来实现。
    - 利用 Props 实现组件通信   
        - Props 实现父子组件通信
            轻量的合适的解决方案, 如果你的组件结构都是标准的父子结构,
            - 祖先组件 怎么办？
                你需要利用 Props 层层透传 2 层组件 很烂
        - Props 实现组件间通信
            Props 依赖组件传递, 所以组件间通信也需要一个桥梁（父组件）
            本质上和父子通信是一样的, 区别在于目的不同
    - 利用 Context 实现组件通信
        Context 比 Props 还复杂了一点, 适合家族型态组件
        家族型态组件是指组件嵌套 3 层以上, 形成了非常庞大的嵌套结构, 就像一个繁盛的家族一样, 几代人都生活在一起彼此紧密联系.
        你不需要再为通信的组件建立一条手动传递 Props 的 Channel
        不要滥用

2. Redux 异步解析
    用户通过 dispatch 发起 Action 后
    reducer 会立即计算返回新的 state， 这是一个 同步 的过程
    如果我们想在 Action 发起之后， 过一段时间再执行 reducer 计算 state， 即 异步计算 state ?
    1. Redux 中， Action对象 只是一个简单的 js对象  plain Object  
    2. Reducer 也是一个 js 纯函数 只负责 根据 Action 对象计算 state， 不会进行 API 请求和路由跳转
    3. 我们只能在发送 Action 的时候做些文章， 即对 dispatch 方法做改造， 使得 dispatch 方法可以进行 异步操作

    redux-thunk 是供 redux 使用的一个 中间件(middleware)
    这个中间件会对 store对象 原生的 dispatch 方法 进行包装， 然后返回一个 新的dispatch方法(闭包)
    我们给这个 新的dispatch方法 传入一个函数， 即 dispatch(func), 在这个函数中我们执行 异步操作，然后在 异步操作的回调方法中执行 原生的dispatch(action) 操作， 修改 state。

    Actions must be plain objects. Instead, the actual type was: 'function'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions

    在 thunk函数 中， 我们可以执行 异步操作， 然后在 异步操作 的 回调方法 中调用 store 的原生 dispatch 方法， 派发 Action， 触发 state 的修改。

- koa-cors 能跨域的原理是什么？
    - 当发生跨域的时候。如果没有引入这个 cors 那么就会被同源策略限制到。
    - 返回的响应头
        Access-Control-Allow-Origin: http://127.0.0.1:5501

    - 什么是跨域
        浏览器对于javascript的同源策略的限制
        例如http://a.cn下面的js不能调用http://b.cn中的js,对象或数据(因为http://a.cn和http://b.cn是不同域),所以跨域就出现了.

        - 同域：简单的解释就是域名相同,端口相同,协议相同
        - 为什么需要跨域

- 302 303  304 区别
    301 302 303 307 308
    3XX 表示重定向的响应
    301 Moved Permanently    永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
    302 Moved Temporarily   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
    303 See Other           查看其它地址。与301类似。使用GET和POST请求查看
    307 Temporary Redirect   临时重定向。与302类似。使用GET请求重定向
    308 Permanent Redirect    

- 临时重定向和永久重定向对搜索引擎会产生不同的效果
- 302、303 与 307 从临时重定向开始
    302 状态码表示目标资源临时移动到了另一个 URI 上。由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。
    服务器会在响应 Header 的 Location 字段中放上这个不同的 URI。浏览器可以使用 Location 中的 URI 进行自动重定向。
    用户代理可能会在重定向后的请求中把 POST 方法改为 GET 方法。如果不想这样，应该使用 307（Temporary Redirect） 状态码
    303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述
    303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。
    不管原请求是什么方法，重定向请求的方法都是 GET
    307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。
- 308 的定义实际上和 301 是一致的
    唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。
- 304 Not Modified


- 协商缓存和强缓存的区别
    - 强缓存
        使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求
        强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性
        - 服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果
        - Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值：
            - public 
                设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存， 这个字段值不常用，max-age=来精确控制
            - private 
                该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存
            - no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源
                no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
            -  no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
                no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
            - max-age=：设置缓存的最大有效期，单位为秒
            - s-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头
            - max-stale=：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制
            当两种方式一起使用时，Cache-Control 的优先级要高于 Expires
- 协商缓存
    - 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。
    命中协商缓存的条件有两个：
        - max-age=xxx 过期了
        - 值为no-cache
            如果资源没有发生修改，则返回一个 304 状态
    - Etag 和 Last-Modified 
        服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间
        当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值
        如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存
        使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。
        因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

        当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。


强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。

为什么需要浏览器缓存？
    对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。
所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

    使用浏览器缓存，有以下优点：
    - 减少了服务器的负担，提高了网站的性能
    - 加快了客户端网页的加载速度
    - 减少了多余网络数据传输

- 防抖节流
    应用场景

    - 函数防抖  debounce
        在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
        可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。  googleSearch
        只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。
    - 函数节流(throttle)
        规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

    - 总结
        - 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。
        - 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。
    - 结合应用场景
        debounce  
            search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
            window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
        throttle
            鼠标不断点击触发，mousedown(单位时间内只触发一次)  强红包
            监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

- flex
    flex: 1
        由 flex-grow: 1 
            flex-shrink:1
            flex-basis: 0%;
        flex-basis 会生效
            https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
        
    order:
        order 为整数，可以为负数。
        order 默认值为 0。
        项目按照 order 值从小到大排列。
    
- 红绿灯