// 不可以，因为闭包过度使用会导致性能问题，
function foo() {
    var a = 2;
  
    function bar() {
      console.log( a );
    }
  
    return bar;
  }
  
  var baz = foo();
  
  baz();

//   它却有可能导致 内存泄露。
//   我们知道，javascript 内部的垃圾
//   回收机制用的是引用计数收集：即当内存中的一个
//   变量被引用一次，计数就加一。垃圾回收机制会以
//   固定的时间轮询这些变量，将计数为 0 的变量标记
//   为失效变量并将之清除从而释放内存。
// foo 函数作用域隔绝了外部环境，所有变量引用都在函数内部完成
// foo 运行完成以后，内部的变量就应该被销毁，内存被回收
// 闭包导致了全局作用域始终存在一个 
// baz 的变量在引用着 foo 内部的 bar 函数
// foo 内部定义的 bar 函数引用数始终为 1，垃圾运行机制就无法把它销毁。
// bar 有可能还要使用到父作用域 foo 中的变量信息，那它们自然也不能被销毁... JS 引擎无法判
// 断你什么时候还会调用闭包函数，只能一直让这些数据占用着内存
// 由于闭包使用过度而导致的内存占用无法释放的情况，我们称之为：内存泄露