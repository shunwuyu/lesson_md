[source](https://zhuanlan.zhihu.com/p/130333796)
- https://cloud.tencent.com/developer/labs/lab/10068/console


- 什么叫对称加密， 非对称加密？
  服务端有非对称加密的公钥A1，私钥A2；
客户端有非对称加密的公钥B1，私钥B2；
客户端向服务端发起请求，服务端将公钥A1返回给客户端；
浏览器收到公钥A1，将自己保存的公钥B1发送给服务端；
之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密；
客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密。
为什么不？
非对称加解密耗时要远大于对称加解密，对性能有很大损耗，大家的使用体验很差。

服务端有非对称加密的公钥A1，私钥A2；
客户端发起请求，服务端将公钥A1返回给客户端；
客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端；
服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题
之后双方通信都使用密钥K进行对称加解密。

兼顾了安全性和性能，但是，真的就安全了么？
依然考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。

当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。

而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获，中间人利用自己的私钥B2解密，得到密钥K，再使用服务端的公钥A1加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知。

客户端无法确认收到的公钥是不是真的是服务端发来的。
服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份数字证书，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。

- 客户端得到证书，分解成明文部分Text和数字签名Sig1
- 用CA机构的公钥进行解签，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）
- 用证书里声明的哈希算法对明文Text部分进行哈希得到H
- 当自己计算得到的哈希值T与解签后的Sig2相等，表示证书可信，没有被篡改
网银证书




简述https原理，以及与http的区别

Google Chrome将非 HTTPS 的网站标注为「不安全」
www.baidu.com  ->  https://www.baidu.com    301 永久转移  
302 暂时跳转  

HTTP 有着一个致命的缺陷，那就是内容是明文传输的 没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）中间人攻击

你坐在教室靠墙的一边   晚上放学操场我等你   坐在窗边的小红，中间要经过六七个人的传递。

如果有小刚也喜欢小红，看到你俩马上就要甜甜蜜蜜地回家了，心有不甘，换了一张纸条，改成了「晚上放学你自己回家吧，我要去网吧玩游戏」

小红看到你要抛弃她自己去玩游戏，非常伤心，开始在纸条上质问「说好的一起回家呢，为什么要去打游戏，哼」。

在小红的纸条传回来的路上，小刚又改了纸条「你玩你的游戏去吧，我要和小刚回家」。

运营商劫持  广告标签、跳转脚本、欺骗性的红包按钮，甚至有时候本来要下载一个文件  被运营商劫持了HTTP明文数据的现象。 网页弹窗
![](https://pic3.zhimg.com/80/v2-bcb1a55de33b95000c35770900a4c90a_1440w.jpg)

Hypertext Transfer Protocol
1994年网景公司提出了HTTPS  HyperText Transfer Protocol Secure  
数据通信仍然是HTTP，但利用SSL/TLS加密数据包。

SSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；
4. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；
6. 服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；
7. 服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用随机Key对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。

## 对称加密与非对称加密
对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。如果通信双方都持有密钥，且天知地知你知我知，绝对不会有别的人知道，那么通信安全自然是可以得到保证的（在密钥足够强的情况下）。
在HTTPS的传输场景下，服务端事先并不知道客户端是谁，你也不可能在事先不通过互联网和每一个网站的管理员都悄悄商量好一个通信密钥出来，那么必然存在一个密钥在互联网上传输的过程，如果在传输过程中被别人监听到了，那么后续的所有加密都是无用功。
非对称加密。
有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。
那么，当客户端发起连接请求，服务端将公钥传输过去，客户端利用公钥加密好信息，再将密文发送给服务端，服务端里有私钥可以解密。

但是，当服务端要返回数据，如果用公钥加密，那么客户端并没有私钥用来解密，而如果用私钥加密，客户端虽然有公钥可以解密，但这个公钥之前就在互联网上传输过，很有可能已经有人拿到，并不安全，所以这一过程只用非对称加密是不能满足的。

非对称加解密耗时要远大于对称加解密
1. 服务端有非对称加密的公钥A1，私钥A2；
2. 客户端发起请求，服务端将公钥A1返回给客户端；
3. 客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端；
4. 服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题
5. 之后双方通信都使用密钥K进行对称加解密。

